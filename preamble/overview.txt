.. _clause_overview_of_cloud_storage:

Overview of Cloud Storage
=========================

********
Overview
********

When discussing cloud storage and standards, it is important to distinguish the various resources that are being offered as services. These resources are exposed to clients as functional interfaces (i.e., data paths) and are managed by management interfaces (i.e., control paths). This International Standard explores the various types of interfaces that are part of cloud services today and shows how they are related. This International Standard defines a model for the interfaces that can be mapped to the various cloud services and a model that forms the basis for cloud storage interfaces into the future.

Another important concept in this International Standard is that of metadata. When managing large amounts of data with differing requirements, metadata is a convenient mechanism to express those requirements in such a way that underlying data services can differentiate their treatment of the data to meet those requirements.

The appeal of cloud storage is due to some of the same attributes that define other cloud services: pay as you go, the illusion of infinite capacity (elasticity), and the simplicity of use/management. It is therefore important that any interface for cloud storage support these attributes, while allowing for a multitude of business use cases.

What is Cloud Storage?
**********************

The use of the term cloud in describing these new models arose from architecture drawings that typically used a cloud as the icon for a network. The cloud represents any-to-any network connectivity in an abstract way. In this abstraction, the network connectivity in the cloud is represented without concern for how it is made to happen.

The cloud abstraction of complexity produces a simple base on which other features can be built. The general cloud model extends this base by adding a pool of resources. An important part of the cloud model is the concept of a pool of resources that is drawn from, on demand, in small increments. A relatively recent innovation that has made this possible is virtualization. 

Thus, cloud storage is simply the delivery of virtualized storage on demand. The formal term that is used for this is Data storage as a Service (DaaS).

Data Storage as a Service
*************************

By abstracting data storage behind a set of service interfaces and delivering it on demand, a wide range of actual cloud services and implementations are possible. The only type of storage that is excluded from this definition is that which is delivered in fixed-capacity increments instead of that which is based on demand. 

An important part of any DaaS system is the support of legacy clients. Support is accommodated with existing standard protocols such as iSCSI (and others) for block network storage and SMB/NFS or WebDAV for file network storage, as shown in :numref:`fig_legacydsis`.

.. _fig_LegacyDSIs:

.. figure:: /images/LegacyDSIs.*
    :align:  center
    :figwidth: 100%
   
    Existing data storage interface standards

The difference between purchasing a dedicated appliance or purchasing cloud storage is not the functional interface, but the fact that the storage is delivered on demand. Customers pay for either what they actually use or what they have allocated for use. For block storage, a Logical Unit Number (LUN), or virtual volume, is the granularity of allocation. For file protocols, a file system is the unit of granularity. In either case, the actual storage space may be thin-provisioned and billed for based on actual usage. Data services, such as compression and deduplication, can be used to further reduce the actual space consumed.

Managing this storage is typically done out of band for these standard data storage interfaces, either through an API, or more commonly, through an administrative browser-based user interface. This out-of-band interface can be used to invoke other data services as well (e.g., snapshots or cloning).

In this model, the underlying storage space that has been exposed by the out-of-band interfaces is abstracted and exposed using the notion of a container. A container is not only a useful abstraction for storage space, but also serves as a grouping of the data stored in it and a point of control for applying data services in the aggregate.

Each data object is created, retrieved, updated, and deleted as a separate resource. In this type of interface, a container, if used, is a simple grouping of data objects for convenience. Nothing prevents the concept of containers from being hierarchical, although any given implementation might support only a single level (see :numref:`fig_crud`).

.. _fig_CRUD:

.. figure:: /images/CRUD.*
    :align:  center
    :figwidth: 100%
    
    Storage interfaces for object storage client data

Data management for cloud storage
*********************************

Many of the initial implementations of cloud storage focused on a kind of best effort quality of storage service and ignored most other types of data services. To address the needs of enterprise applications with cloud storage, however, there is an increasing need to offer better quality of service and to deploy additional data services.

Cloud storage can lose its abstraction and simplicity benefits if new data services that require complex management are added. Cloud storage customers are likely to resist new demands on their time (e.g., setting up backup schedules through dedicated interfaces, deploying data services individually for stored objects).

By supporting metadata in a cloud storage interface and prescribing how the storage system and data system metadata is interpreted to meet the requirements of the data, the simplicity required by the cloud storage model can be maintained while still addressing the requirements of enterprise applications and their data.

User metadata is retained by the cloud and can be used to find the data objects and containers by performing a query for specific metadata values. The schema for this metadata may be determined by each application, domain, or user. For more information on support for user metadata, see :numref:`%s <ref_support_for_user_metadata>`.

Storage system metadata is produced/interpreted by the cloud service provider and basic storage functions (e.g., modification and access statistics, access control). For more information on support for storage system metadata, see :numref:`%s <ref_support_for_storage_system_metadata>`.

Data system metadata is interpreted by the cloud service provider as data requirements that control the operation of underlying data services for that data. Depending on the level of granularity supported by the cloud, data system metadata may apply to an aggregation of data objects in a container or to individual data objects, if the cloud service provider supports this level of granularity. For more information on support for data system metadata, see :numref:`%s <ref_support_for_data_system_metadata>`.

.. _ref_data_and_container_management:

Data and container management
*****************************

There is no reason that managing data and managing containers should involve different interfaces. Therefore, the use of metadata is extended from applying to individual objects to applying to containers of objects as well. Thus, any data placed into a container inherits the data system metadata of the container into which it was placed. When creating a new container within an existing container, the new container would similarly inherit the metadata settings of its parent's data system metadata. After an object is created, the data system metadata can be overridden at the container or individual object level, as desired.

Even if the provided interface does not support setting metadata on individual objects, metadata can still be applied to the containers. In such a case, the interface does not provide a mechanism to override metadata that an individual object inherits from its parent container. For file-based interfaces that support extended attributes (e.g., SMB, NFSv4), these extended attributes may be used to specify the data system metadata to override that specified for the container. 

********************************************
Reference model for cloud storage interfaces
********************************************

The cloud storage reference model is shown in :numref:`fig_reference_model_for_cloud_storage_interfaces`.

.. _fig_reference_model_for_cloud_storage_interfaces:

.. figure:: /images/CloudStorageRefModelNoShadow.*
    :align:  center
    :figwidth: 100%
    
    Cloud storage reference model

This model shows multiple types of cloud data storage interfaces that are able to support both legacy and new applications. All of the interfaces allow storage to be provided on demand, drawn from a pool of resources. The storage capacity is drawn from a pool of storage capacity provided by storage services. The data services are applied to individual objects, as determined by the data system metadata. Metadata specifies the data requirements on the basis of individual objects or for groups of objects (containers).

*******************************
Cloud data management interface
*******************************

The Cloud Data Management Interface (CDMIâ„¢) shown in :numref:`fig_reference_model_for_cloud_storage_interfaces` may be used to create, retrieve, update, and delete objects in a cloud. The features of the CDMI include functions that: 

* allow clients to discover the capabilities available by the cloud service provider,
* manage containers and the data that is placed in them, and
* allow metadata to be associated with containers and the objects they contain.

This International Standard divides operations into two types: those that use a CDMI content type in the HTTP body and those that do not. While much of the same data is available via both types, providing both allows for CDMI-aware clients and non-CDMI-aware clients to interact with a CDMI provider. 

CDMI can also be used by administrative and management applications to manage containers, domains, security access, and monitoring/billing information, even for storage that is functionally accessible by legacy or proprietary protocols. The capabilities of the underlying storage and data services are exposed so that clients can understand what services the cloud service provider provides. 

Conformant cloud service providers can support a subset of the CDMI, as long as they expose the limitations in the capabilities reported via the interface.

This International Standard uses RESTful principles in the interface design where possible (see :cite:`restthesis`). 

CDMI defines both a means to manage the data as well as a means to store and retrieve the data. The means by which the storage and retrieval of data is achieved is termed a data path. The means by which the data is managed is termed a control path. CDMI specifies both a data path and control path interface. 

CDMI does not need to be used as the only data path and is able to manage cloud storage properties for any data path interface (e.g., standardized or vendor specific). 

Container metadata is used to configure the data requirements of the storage provided through the exported protocol (e.g., block protocol or file protocol) that the container exposes. When an implementation is based on an underlying file system to store data for a block protocol (e.g., iSCSI), the CDMI container provides a useful abstraction for representing the data system metadata for the data and the structures that govern the exported protocols. 

A cloud service may also support domains that allow administrative ownership to be associated with stored objects. Domains allow this International Standard to (among other things): 

* determine how user credentials are mapped to principals used in an Access Control List (ACL),
* allow granting of special cloud-related privileges, and
* allow delegation to external user authorization systems (e.g., LDAP or Active Directory).

Domains may also be hierarchical, allowing for corporate domains with multiple children domains for departments or individuals. The domain concept is also used to aggregate usage data that is used to bill, meter, and monitor cloud use.

Finally, capabilities allow a client to discover the capabilities of a CDMI implementation. Requirements throughout this International Standard shall be understood in the context of CDMI capabilities. Mandatory requirements on functionality that is conditioned on a CDMI capability shall not be interpreted to require implementation of that capability, but rather shall be interpreted to apply only to implementations that support the functionality required by that capability.

For example, in :numref:`%s <ref_object_id>`, this International Standard states, "Every cloud storage system shall allow object ID-based access to stored objects." This requirement shall be understood in the context that access by object ID is predicated on the presence of the ``cdmi_object_access_by_ID`` capability.

.. _ref_object_model_for_cdmi:

Object model for CDMI
*********************

The model for CDMI is shown in :numref:`fig_cdmi_object_model`.


.. _fig_cdmi_object_model:

.. figure:: /images/CDMIUMLEntitiesDiagram.*
    :align:  center
    :figwidth: 100%
    
    CDMI object model

The five types of resources defined are shown in :numref:`tbl_types_of_resources_in_model`. The content type in any given operation is specific to each type of resource.

.. tabularcolumns:: |>{\raggedright\arraybackslash}\Y{0.20}
                    |>{\raggedright\arraybackslash}\Y{0.60}
                    |>{\raggedright\arraybackslash}\Y{0.20}|

.. _tbl_types_of_resources_in_model:

.. list-table:: Types of resources in the CDMI object model
    :header-rows: 1
    :align: center

    * - Resource type
      - Description
      - Reference
    * - Data objects
      - Data objects are used to store data and associated metadata, and provide functionality similar to files in a file system.
      - See :numref:`clause %s <clause_cdmi_data_object>`.
    * - Container objects
      - Container objects have zero or more children objects, and store metadata associated with the container as a whole. Container objects do not store data directly. They provide functionality similar to directories in a file system.
      - See :numref:`clause %s <clause_cdmi_container_object>`.
    * - Domain objects
      - Domain objects represent administrative groupings for user authentication and accounting purposes.
      - See :numref:`clause %s <clause_cdmi_domain_object>`.
    * - Queue objects 
      - Queue objects store zero or more pieces of data, and store metadata associated with the queue as a whole. Enqueued values are accessed in a first-in-first-out manner.
      - See :numref:`clause %s <clause_cdmi_queue_object>`.
    * - Capability objects
      - Capability objects describe the functionality implemented by a CDMI server and are used by a client to discover supported functionality.
      - See :numref:`clause %s <clause_cdmi_capability_object>`.

For data storage operations, the client of the interface only needs to know about container objects and data objects. All data path implementations are required to support at least one level of containers (see :numref:`%s <ref_data_and_container_management>`). Using the CDMI object model (see :numref:`fig_cdmi_object_model`), the client can send a PUT via CDMI (see :numref:`fig_reference_model_for_cloud_storage_interfaces`) to the new container URI and create a new container with the specified name. Container metadata are optional and are expressed as a series of name-value pairs. After a container is created, a client can send a PUT to create a data object within the newly created container.

Queue objects are also defined (see :numref:`fig_cdmi_object_model`) and provide in-order-first in-first-out access to enqueued objects. More information on queues can be found in :numref:`clause %s <clause_cdmi_queue_object>`. 

CDMI defines two namespaces that can be used to access stored objects, a flat object ID namespace and a hierarchical path-based namespace. Support for objects accessed by object ID is indicated by the system-wide capability ``cdmi_object_access_by_ID``, and support for objects accessed by hierarchical path is indicated by the container capability cdmi_create_dataobject found on the root container (and any subcontainers).

Objects are created by ID by performing an HTTP POST against a special URI, designated as ``/cdmi_objectid/`` (see :numref:`%s <ref_cdmi_container_object_create_post_object>`). Subsequent to creation, objects are modified by performing PUTs using the object ID assigned by the CDMI server, using the "``/cdmi_objectid/``" URI (see :numref:`%s <ref_cdmi_data_object_update>`). The same URI is used to retrieve and delete objects by ID. 

Objects are created by name by performing an HTTP PUT to the desired path URI (see :numref:`%s <ref_cdmi_data_object_create>`). Subsequent to creation, objects are modified by performing PUTs using the object path specified by the client (see :numref:`%s <ref_cdmi_data_object_update>`). The same URI is used to retrieve and delete objects by path. 

CDMI defines mechanisms so that objects having only an object ID can be assigned a path location within the hierarchical namespace, and so that objects having both an object ID and path can have their path dropped, such that the object only has an object ID. This function is accomplished by using a "move" modifier to a PUT or POST operation, as shown in :numref:`fig_cdmiobjectlifecycle`.

.. _fig_CDMIObjectLifecycle:

.. figure:: /images/CDMIObjectLifecycle.*
    :align:  center
    :figwidth: 100%
    
    Object transitions between named and ID-only

CDMI metadata
*************

CDMI uses many different types of metadata, including HTTP metadata, data system metadata, user metadata, and storage system metadata.

HTTP metadata is metadata that is related to the use of the HTTP protocol (e.g., Content-Length, Content-Type, etc.). HTTP metadata is not specifically related to this International Standard but needs to be discussed to explain how CDMI uses the HTTP standard.

CDMI data system metadata, user metadata, and storage system metadata is defined in the form of name-value pairs. Vendor-defined data system metadata and storage system metadata names shall begin with the reverse domain name of the vendor.

Data system metadata is metadata that is specified by a CDMI client and is a component of objects. Data system metadata abstractly specifies the data requirements associated with data services that are deployed in the cloud storage system.

User metadata consists of client-defined JSON strings, arrays, and objects that are stored in the metadata field. The namespace used for user metadata names is self-administered (e.g., using the reverse domain name), and user metadata names shall not begin with the prefix "``cdmi_``".

Storage system metadata is metadata that is generated by the storage services in the system (e.g., creation time, size) to provide useful information to a CDMI client. 

The matrix of the creation and consumption of storage system metadata is shown in :numref:`tbl_create_consume_storage_system_metadata`.

.. _tbl_create_consume_storage_system_metadata:

.. list-table:: Creation/consumption of storage system metadata
    :header-rows: 1
    :stub-columns: 1
    :widths: auto
    :align: center
    
    * - \ 
      - Created by user 
      - Created By system
    * - Consumed by user
      - User metadata
      - Storage system metadata
    * - Consumed by system
      - Data system metadata
      - N/A

.. _ref_object_id:

CDMI object IDs
***************

Every object stored within a CDMI-compliant system shall have a globally unique object identifier (ID) assigned at creation time. The CDMI object ID is a string with requirements for how it is generated and how it obtains its uniqueness. Each cloud service that implements CDMI shall generate these identifiers such that the probability of conflicting with identifiers generated by other CDMI Servers and the probability of generating an identifier that has already been used is effectively zero. 

Every cloud storage system shall allow object ID-based access to stored objects by allowing the object's ID to be appended to the root URI (see :numref:`%s <ref_cdmi_uris>`). If the data object "``MyDataObject.txt``", stored in the root container "``/``" with a root path of "``/cdmi/2.0.0/``", has an object ID of "``00006FFD001001CCE3B2B4F602032653``", the following pair of URIs access the same data object: 

* ``https://cloud.example.com/cdmi/2.0.0/MyDataObject.txt``
* ``https://cloud.example.com/cdmi/2.0.0/cdmi_objectid/00006FFD001001CCE3B2B4F602032653``

If containers are supported, they shall also be accessible by object ID. If the container "MyContainer", stored in the root container "``/``" with a root path of "``/cdmi/2.0.0/``", has an object ID of "``00006FFD0010AA33D8CEF9711E0835CA``", the following pairs of URIs access the same object: 

* ``https://cloud.example.com/cdmi/2.0.0/MyContainer/``
* ``https://cloud.example.com/cdmi/2.0.0/cdmi_objectid/00006FFD0010AA33D8CEF9711E0835CA/``
* ``https://cloud.example.com/cdmi/2.0.0/MyContainer/MyDataObject.txt``
* ``https://cloud.example.com/cdmi/2.0.0/cdmi_objectid/00006FFD0010AA33D8CEF9711E0835CA/MyDataObject.txt``

CDMI object ID format
*********************

The CDMI Server shall create the object ID, which identifies an object. The object ID shall be globally unique and shall conform to the format defined in :numref:`tbl_objectid_format`. The native format of an object ID is a variable-length byte sequence and shall be a maximum length of 40 bytes. A client should treat object IDs as opaque byte strings. However, the object ID format is defined such that its integrity may be validated, and independent CDMI Servers may assign unique object ID values independently.

.. _tbl_objectid_format:

.. table:: Object ID format
   
    +-----------------+---+---+-----------+-----------------+--------+---+---+---+---+----+-----+----+----+
    | 0               | 1 | 2 | 3         | 4               | 5      | 6 | 7 | 8 | 9 | 10 | ... | 38 | 39 |
    +=================+===+===+===========+=================+========+===+===+===+===+====+=====+====+====+
    | Reserved (zero) | Enterprise Number | Reserved (zero) | Length | CRC   | Opaque Data                |
    +-----------------+-------------------+-----------------+--------+-------+----------------------------+

The fields shown in :numref:`tbl_objectid_format` are defined as follows:

* The reserved bytes shall be set to zero.
* The Enterprise Number field shall be the SNMP enterprise number of the offering organization that developed the system that created the object ID, in network byte order. See RFC 2578 :cite:`rfc2578` and https://www.iana.org/assignments/enterprise-numbers. 0 is a reserved value.
* The byte at offset 5 shall contain the full length of the object ID, in bytes.

* The CRC field shall contain a 2-byte (16-bit) CRC in network byte order. The CRC field enables the object ID to be validated for integrity. The CRC field shall be generated by running the CRC algorithm across all bytes of the object ID, as defined by the Length field, with the CRC field set to zero. The CRC function shall have the following fields:

    - Name 	: "CRC-16",
    - Width 	: 16,
    - Poly 	: ``0x8005``,
    - Init 	: ``0x0000``,
    - RefIn 	: True,
    - RefOut 	: True,
    - XorOut 	: ``0x0000``, and
    - Check 	: ``0xBB3D``.
  
  This function defines a 16-bit CRC with polynomial ``0x8005``, reflected input, and reflected output. 

* Opaque data in each object ID shall be unique for a given Enterprise Number.

The native format for an object ID is binary. When necessary, such as when included in URIs and JSON strings, the object ID textual representation shall be encoded using Base16 encoding rules described in RFC 4648 :cite:`rfc4648` and shall be case insensitive. 

********
Security
********

Security objectives
*******************

Security, in the context of CDMI, refers to the protective measures employed in managing and accessing data and storage. The specific objectives to be addressed by security include providing a mechanism that: 

* assures that the communications between a CDMI client and server cannot be read or modified by a third party; 
* allows CDMI clients and servers to assure their identity; 
* allows control of the actions a CDMI client is permitted to perform on a CDMI server; 
* allows records to be generated for actions performed by a CDMI client on a CDMI server; 
* protects data at rest; 
* eliminates data in a controlled manner; and 
* discovers the security capabilities of of a particular implementation. 

Security measures within CDMI are summarized as: 

* transport security, 
* user and entity authentication, 
* authorization and access controls, 
* data integrity, 
* data and media sanitization, 
* data retention, 
* protections against malware, 
* data at-rest encryption, and 
* security capabilities. 

With the exception of both the transport security and the security capabilities, which are mandatory to implement, the security measures can vary significantly from implementation to implementation.

When security is a concern, the CDMI client should begin with a series of security capability lookups (see :numref:`%s <ref_cloud_storage_system-wide_capabilities>`  to determine the exact nature of the security features that are available. Based on the values of these capabilities, a risk-based decision should be made as to whether the CDMI server should be used. This is particularly true when the data to be stored in the cloud storage is sensitive or regulated in a way that requires stored data to be protected (e.g., encrypted) or handled in a particular manner (e.g., full accountability and traceability of management and access).

HTTP security
*************

HTTP is the mandatory transport mechanism for this version of CDMI. It is important to note that HTTP, by itself, offers no confidentiality or integrity protections. As CDMI is built on top of HTTP, HTTP over Transport Layer Security (TLS) (i.e., HTTPS) is the mechanism that is used to secure the communications between CDMI clients and servers. 

To ensure both security and interoperability, all CDMI implementations:

* shall implement the TLS protocol as described in the latest version of the "SNIA TLS Specification for Storage Systems" :cite:`snia-tls`; with a six-month transition period for implementations. The TLS specification is updated when new vulnerabilities are found, and CDMI implementations shall support the latest specification within six months of its publication announcement;
* shall support both HTTP over TLS and HTTP without TLS; and 
* shall allow HTTP without TLS to be disabled.

When TLS is used to secure HTTP, the client and server typically perform some form of entity authentication. However, the specific nature of this entity authentication depends on the cipher suite negotiated; a cipher suite specifies the encryption algorithm and digest algorithm to use on a TLS connection. A very common scenario involves using server-side certificates, which the client trusts, as the basis for unidirectional entity authentication. It is possible that mutual authentication involving both client-side and server-side certificates are required.

.. _ref_overview_authentication:

Client Authentication
*********************

A CDMI client shall comply with all security requirements for HTTP that apply to clients. 

CDMI clients shall be responsible for initiating user authentication for each CDMI operation that is performed. The CDMI server functions as the authenticator and receives and validates authentication credentials from the client.

RFC 2616 :cite:`rfc2616` and RFC 2617 :cite:`rfc2617` define requirements for HTTP authentication, which generally starts with an HTTP client request. If the client request does not include an "Authorization" header and authentication is required, the server responds with an HTTP status code of ``401 Unauthorized`` and a WWW-Authenticate response header. The HTTP client shall then respond with the appropriate Authorization header in a subsequent request. The format of the WWW-Authenticate and Authorization headers varies depending on the type of authentication required.

* 	HTTP basic authentication involves sending the user name and password in the clear, and it should only be used on a secure network or in conjunction with TLS.
* 	HTTP digest authentication sends a secure digest of the user name and password (and other information such as a nonce value), and can be used on an insecure network without TLS.
* 	HTTP status codes of ``401 Unauthorized`` should not include a choice of authentication.
* 	HTTP basic authentication and/or HTTP digest authentication should be implemented.
* 	Authentication credentials used with one type of HTTP authentication (i.e., basic or digest) should never be subsequently used with the other type of HTTP authentication.

Once a user is authenticated, the provided principal name shall be mapped by the CDMI domain to a domain user (or used directly as the ACE "``who``" if domains are not supported). This mapping is then used to determine authorization.

A CDMI server typically relies on an authentication service (local and/or external) to validate client credentials. Differing authentication schemes may be supported, including host-based authentication, Kerberos, PKI, or other; the authentication service is beyond the scope of this International Standard.

Use of TLS and HTTP
*******************

Recommendations for using HTTP and TLS are as follows:

* 	A client connecting to a CMDI server using TLS should use TCP port 443, and a client connecting without TLS should use TCP port 80.
* 	A client that fails to connect to a CDMI server on port 443 should retry without TLS on TCP port 80 if their security policy allows it.
* 	Servers may respond to HTTP requests on port 80 with an HTTP REDIRECT to the appropriate TLS URI (using port 443). Clients should honor such redirects in this situation.

Further information
*******************

For further information pertaining to storage security techniques, see the latest version of ISO 20648. 

*********************
Required HTTP support
*********************

RFC 2616 support requirements
*****************************

A conformant implementation of CDMI shall also be a conformant implementation of RFC 2616 :cite:`rfc2616` (i.e., HTTP 1.1). The subclauses below list the sections of RFC 2616 :cite:`rfc2616` that shall be supported; however, this list is not comprehensive.

.. _ref_content-type_negotiation:

Content-Type negotiation
************************

For CDMI operations, media types for CDMI objects are used as defined in RFC 6208 :cite:`rfc6208`. All CDMI representations follow the rules established for "application/json" as defined in RFC 4627 :cite:`rfc4627`. The use of the CDMI media types with the "+json" suffix shall be supported as defined in RFC 6839 :cite:`rfc6839`. 

A client can optionally supply an HTTP Accept header, as per section 14.1 of RFC 2616 :cite:`rfc2616`. If a client is restricting the response to a specific CDMI media type, the corresponding media type shall be specified in the Accept header. Otherwise, the Accept header can contain "``*/*``" or a list of media types, or it may be omitted. 

If a request body is present, the client shall include a Content-Type header, as per section 14.17 of RFC 2616 :cite:`rfc2616`. If the client does not provide a Content-Type header when required or provides a media type in the Content-Type header that does not match with the existing resource media type, the server shall return an HTTP status code of ``400 Bad Request``.

If a response body is present, the server shall provide a ``Content-Type`` header. 

This International Standard may further qualify content negotiation (e.g., in :numref:`%s <ref_cdmi_container_object_read>`, the absence of a ``Content-Type`` header has a specific meaning).

Range support
*************

The server shall support HTTP Range headers and partial content responses (see Section 14.16 of RFC 2616 :cite:`rfc2616`). 

The values of the childrange, valuerange and queuerange fields are formatted based on the HTTP byte-range-resp-spec, as defined in clause 14.16 of RFC 2616 :cite:`rfc2616`.

URI escaping
************

Percent escaping of reserved characters specified in RFC 3986 :cite:`rfc3986` shall be applied to all text strings used in HTTP request URIs and HTTP header URIs. This includes user-supplied field names, metadata names, data object names, container object names, queue object names, and domain object names when used in HTTP request URIs and HTTP header URIs. 

Field names and values shall not be escaped when stored and when sent in request body and response bodies.

A client retrieving a metadata item named "@user" from a container object with the name of "@MyContainer" would perform the following request:

.. code-block:: none

    GET /cdmi/2.0.0/%40MyContainer/?objectName&metadata=%40user HTTP/1.1
    Host: cloud.example.com
    Accept: application/cdmi-container

The response shall be:

.. code-block:: none

    HTTP/1.1 200 OK
    Content-Type: application/cdmi-container
    
    {
        "objectName": "@MyContainer/",
        "metadata": {
            "@user": "test",
            ...
        }
    }

.. _ref_cdmi_uris:

Use of URIs
***********

The format and syntax of URIs are defined by RFC 3986 :cite:`rfc3986`.

This International Standard splits the RFC 3986 path into two parts: The "root path" and the "CDMI path", as shown in :numref:`fig_cdmi_uris`. The URI containing only the root path is called the "root URI".

.. _fig_CDMI_URIs:

.. figure:: /images/cdmi_uris.*
    :align:  center
    :figwidth: 100%
    
    CDMI URI Components

The container at the start of the CDMI path is the root container. For example, in :numref:`fig_cdmi_uris`, the root container is named "``myContainer``".

All URIs in this International Standard are relative to the root URI unless otherwise noted. As a consequence, the algorithm used for calculating the resolved URI is as described in Section 5.2 of RFC 3986 :cite:`rfc3986`. Every CDMI client shall maintain one or more root URIs that each correspond to a root CDMI container on the CDMI server. Since all URIs to CDMI containers end in a trailing slash, all root URIs will end in a trailing slash. 

This International Standard places no additional restrictions on root URIs beyond those specified for the "path component" in RFC 3986.

Industry conventions for RESTful APIs suggest root URIs end in "``/cdmi/<version>/``", where <version> is in the form of "``<major>.<minor>.<micro>``", where <major>, <minor> and <micro> are integers indicating the version of the CDMI interface specification. All examples in this specification use a root URI of ``https://cloud.example.com/cdmi/2.0.0/``.

The properties of the root URI determine the ``parentID`` and ``parentURI`` fields of an root CDMI container:

* If the root path is "``/``", the root container shall not include the ``parentID`` field and shall populate an empty string ("") for the value of the ``parentURI`` field.
* If the root path is not "``/``" and the last entity in the root path is a CDMI container, the root container shall populate ``parentID`` field with the CDMI object ID of the CDMI container corresponding to the parent path entity, and shall populate the ``parentURI`` field with the URI of the parent path.
* If the root path is not "``/``" and the last entity in the root path is not a CDMI container, the root container shall not include the ``parentID`` field, and shall populate the ``parentURI`` field with the URI of the parent path.
* If the root path  is not "``/``" and the last entry in the root path is not accessible via the scheme, root container may omit the ``parentID`` field and may populate ``parentURI`` field with an empty string ("").

:numref:`tbl_relative_uris_resolved_against_root_uris` shows how CDMI paths (relative URIs) are resolved with root URIs

.. _tbl_relative_uris_resolved_against_root_uris:

.. list-table:: Relative URIs resolved against root URIs
    :header-rows: 1
    :widths: 30 22 48
    :align: center

    * - Root URI
      - \+ CDMI Path
      - \=> Resolved URI
    * - ``https://cloud.example.com/``
      - 
      - ``https://cloud.example.com/``
    * - ``https://cloud.example.com/``
      - ``/``
      - ``https://cloud.example.com/``
    * - ``https://cloud.example.com/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/myCDMIcontainer/testObject``
    * - ``https://cloud.example.com/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/container/testObject``
    * - ``https://cloud.example.com/myNonCDMIentity/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/myNonCDMIentity/myCDMIcontainer/testObject``
    * - ``https://cloud.example.com/myNonCDMIentity/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/myCDMIcontainer/testObject``
    * - ``https://cloud.example.com/cdmi/2.0.0/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/cdmi/2.0.0/myCDMIcontainer/testObject``
    * - ``https://cloud.example.com/cdmi/2.0.0/``
      - ``myCDMIcontainer/testObject``
      - ``https://cloud.example.com/myCDMIcontainer/testObject``


Reserved characters
*******************

The name of CDMI data objects, container objects, queue objects, domain objects and capability objects shall not contain the "``/``" or "``?``" characters, as these characters are reserved for delimiters.

.. _ref_time_representations:

********************
Time representations
********************

Unless otherwise specified, all date/time values are in the ISO 8601:2004 extended representation ("``YYYY-MM-DDThh:mm:ss.ssssssZ``"). The full precision shall be specified, the sub-second separator shall be a "``.``", the "``Z``" UTC zone indicator shall be included, and all timestamps shall be in UTC time zone. The "``YYYY-MM-DDT24:00:00.000000Z``" hour shall not be used, and instead, it shall be represented as "``YYYY-MM-DDT00:00:00.000000Z``". 

Unless otherwise specified, all date/time intervals are in the ISO 8601:2004 start date/end date representation ("``YYYY-MM-DDThh:mm:ss.ssssssZ/YYYY-MM-DDThh:mm:ss.ssssssZ``"). The end date shall be equal to or later than the start date. The full precision shall be specified, the sub-second separator shall be a "``.``", the "``Z``" UTC zone indicator shall be included, and all timestamps shall be in UTC time zone. The "``YYYY-MM-DDT24:00:00.000000Z`` hour shall not be used, and instead, it shall be represented as "``YYYY-MM-DDT00:00:00.000000Z``". 

***********************
Backwards compatibility
***********************

CDMI client and server implementations shall implement the following measures to ensure backwards compability with earlier versions of this Interational Standard.

See the CDMI 1.1.1 Specification for details on backwards compatiblity specific to the 1.x versions of CDMI.

Specification version detection
*******************************

CDMI 2.x clients shall not include the ``X-CDMI-Specification-Version`` custom header. When a CDMI 2.x client performs an operation against a CDMI 1.x Server, the absence of this header shall result in an error response from the CDMI 1.x server. The client may use the presence of the ``X-CDMI-Specification-Version`` header in an error response as an indication to use CDMI 1.x (which mandates the use of this custom header), if supported.

CDMI 2.x servers may use the presence of the ``X-CDMI-Specification-Version`` custom header from a CDMI 1.x client as an indication to use CDMI 1.x, if supported.

JSON value transfer encoding
****************************

CDMI 2.x servers may support the "json" value transfer encoding. When a CDMI server supports both CDMI 2.x and CDMI 1.x, data objects with a value transfer encoding of json shall be made accessible to CDMI 1.x clients using a value transfer encoding of UTF-8, with the server adding in the required escaping.

*****************
Object references
*****************

Object references are URIs within the cloud storage namespace that redirect to another URI within the same or another cloud storage namespace. References are similar to soft links in a file system. The cloud does not guarantee that the referenced URI will be valid after the time of creation.

References are visible as children in a container and are distinguished from non-references in container children listings by the presence of a trailing "``?``" character added to the reference name. Performing an operation (with the exception of create or delete) to a reference URI will result in an HTTP status code of ``302 Found``, with the HTTP Location header containing the absolute redirect destination URI that was specified at the time the reference was created. The referenceâ€™s destination URI shall not be changed after a reference has been created.

To continue, when CDMI clients receive an HTTP status code of ``302 Found``, they should retry the operation using the URI contained within the Location header.

A delete operation on a reference URI shall delete the reference. References cannot be updated. To update the destination of a redirect, the client shall first delete the reference and then create a new reference to the desired destination.

EXAMPLE 1: GET to a URI, where the URI is a reference:

  .. code-block:: none

      GET /cdmi/2.0.0/MyContainer/MyDataObject.txt HTTP/1.1 
      Host: cloud.example.com 
      Accept: application/cdmi-object 

  The following shows the response.

  .. code-block:: none

      HTTP/1.1 302 Found 
      Location: https://cloud.example.com/cdmi/2.0.0/MyContainer/MyOtherDataObject.txt

  References by object ID shall always redirect to a URI that ends with the same object ID as the request URI. 

EXAMPLE 2: GET to an object ID URI, where the URI is a reference:

  .. code-block:: none

      GET /cdmi/2.0.0/cdmi_objectid/00006FFD0010AA33D8CEF9711E0835CA HTTP/1.1 
      Host: cloud.example.com 
      Accept: application/cdmi-object 

  The following shows the response.

  .. code-block:: none

      HTTP/1.1 302 Found 
      Location: https://archive.example.com/cdmi/2.0.0/cdmi_objectid/00006FFD0010AA33D8CEF9711E0835CA

EXAMPLE 3: PUT to create a reference: 

  .. code-block:: none

      PUT /cdmi/2.0.0/MyContainer/MyDataObject.txt HTTP/1.1
      Host: cloud.example.com Accept: application/cdmi-object
      Content-Type: application/cdmi-object
      
      {
          "reference": "https://cloud.example.com/cdmi/2.0.0/MyContainer/MyOtherDataObject.txt"
      }

  The following shows the response.

  .. code-block:: none
      
      HTTP/1.1 201 Created 

.. raw:: latex

    \newpage

EXAMPLE 4: POST to create a reference:

  .. code-block:: none

      POST /cdmi/2.0.0/cdmi_objectid/ HTTP/1.1 
      Host: cloud.example.com Accept: application/cdmi-object 
      Content-Type: application/cdmi-object 
      
      {
          "reference": "https://cloud.example.com/cdmi/2.0.0/MyContainer/MyOtherDataObject.txt"</P>
      }

  The following shows the response.

  .. code-block:: none

      HTTP/1.1 201 Created
      Location: https://cloud.example.com/cdmi/2.0.0/cdmi_objectid/00007ED90010DF417BAD70A0C7F5CDDA

EXAMPLE 5: DELETE to delete a reference:

  .. code-block:: none

      DELETE /cdmi/2.0.0/MyContainer/MyDataObject.txt HTTP/1.1
      Host: cloud.example.com 

  The following shows the response.

  .. code-block:: none

      HTTP/1.1 204 No Content

