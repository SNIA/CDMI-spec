
<DIV>
.. _50532471_76604:
Capability Object Resource Operations using CDMI
========================================
<DIV>

Overview
************************

Capability objects allow a CDMI™ client to discover what subset of this international standard is implemented by a CDMI provider.

For each URI in a cloud storage system, the set of interactions that the system is capable of performing for that URI are described by the presence of named capabilities. Each capability present for a given URI indicates what functionality the cloud storage system will allow against that URI. Capabilities are always static.

Capabilities may differ from the operations permitted by an Access Control List (ACL) (see :ref:`Access Control`) associated with a given URI‚ e.g., a read-only cloud may not permit write access to a container or object, despite the presence of an ACL allowing write access.

Cloud clients may use capabilities to discover what operations are supported. If an operation is attempted on a CDMI object that does not have a corresponding capability, an HTTP status code of ``400 Bad Request`` shall be returned to the client. All CDMI-compliant cloud storage systems shall implement the ability to read capabilities, but support for the functionality indicated by each capability is optional.

Every CDMI data object, container object, domain object, and queue object shall have a capabilitiesURI field that contains a valid URI of a capabilities object. Within the capabilities object, the name of each capability confers a specific meaning that has been agreed to between the cloud storage provider and the cloud storage consumer. 

The capabilities defined as part of this international standard are described starting in :ref:`Cloud Storage System-Wide Capabilities`. Vendor-defined capabilities not specified in this international standard shall not start with "cdmi_". 

:ref:`Hierarchy of Capabilities` shows the hierarchy of capabilities and shows how the capabilitiesURI links data objects and container objects into the capabilities tree. 


<H6 CLASS="Figure-Caption">
.. _50532471_71322:
Hierarchy of Capabilities</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-6.gif" ALT="">
</DIV>
</TABLE>

The capabilities container within the capabilities tree to which an object is linked is based on the type of the object and the data system metadata fields present in the object. 
<DIV>
<H6 CLASS="Example">
A container with no data system metadata fields specified may map to the "container" capabilities entry.</H6>

As an option, a CDMI implementation may map a container to a "gold_container" capabilities entry, if a data system metadata field is present and set to a given value, such as if the cdmi_data_redundancy field was set to the value of "4". This permits a cloud provider to create profiles of data system metadata fields and values.

Capabilities do not have a CDMI metadata field.
</DIV>
<DIV>

Cloud Storage System-Wide Capabilities
-----

:ref:`System-Wide Capabilities` defines the system-wide capabilities in a cloud storage system. These capabilities, which are found in the capabilities object, are referred to by the root URI (root capabilities).


.. list-table:: <A NAME="50532471_51124"></A>System-Wide Capabilities (Sheet 1 of 4)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_domains
      - JSON String
      - If present and "true", indicates that the cloud storage system supports domains. If not present, the domainURI field shall not be present in response bodies and the "cdmi_domains" URI shall not be present.
    * - cdmi_export_cifs
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports CIFS exports.
    * - cdmi_dataobjects
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports data objects.
    * - cdmi_export_iscsi
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports iSCSI exports.
    * - cdmi_export_nfs
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports NFS protocol exports.
    * - cdmi_export_occi_iscsi
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports OCCI/iSCSI exports.
    * - cdmi_export_webdav
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports WebDAV exports.
    * - cdmi_metadata_maxitems
      - JSON String
      - If present, this capability indicates the maximum number of user-defined metadata items supported per object. If absent, there is no limit placed on the number of user-defined metadata items.
    * - cdmi_metadata_maxsize
      - JSON String
      - If present, this capability indicates the maximum size, in bytes, of each user-defined metadata item supported per object. If absent, there is no limit placed on the size of user- defined metadata items.
    * - cdmi_metadata_maxtotalsize
      - JSON String
      - If present, this capability indicates the maximum size, in bytes, of user-defined metadata supported by the cloud storage system. If absent, there is no limit placed on the size of user-defined metadata.
    * - cdmi_notification
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports notification queues.
    * - cdmi_logging
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports logging queues.
    * - cdmi_query
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports query queues.
    * - cdmi_query_regex
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports query with regular expressions.
    * - cdmi_query_contains
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports query with "contains" expressions.
    * - cdmi_query_tags
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports query with tag-matching expressions.
    * - cdmi_query_value
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports query of value fields.
    * - cdmi_queues
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports queue objects.
    * - cdmi_security_access_control
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports ACLs. See :ref:`Data System Metadata Capabilities` for additional information.
    * - cdmi_security_audit
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports audit logging. See :ref:`Security Logging` for additional information.
    * - cdmi_security_data_integrity
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports data integrity/authenticity. See :ref:`Data System Metadata Capabilities` for additional information.
    * - cdmi_security_encryption
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports data at-rest encryption. See :ref:`Data System Metadata Capabilities` for additional information.
    * - cdmi_security_immutability
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports data immutability/retentions. See :ref:`Data System Metadata Capabilities` for additional information.
    * - cdmi_security_sanitization
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports data/media sanitization. See :ref:`Data System Metadata Capabilities` for additional information.
    * - cdmi_serialization_json
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports JSON as a serialization format.
    * - cdmi_snapshots
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports snapshots.
    * - cdmi_references
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports references.
    * - cdmi_object_move_from_local
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports moving CDMI objects from URIs within the same storage system.
    * - cdmi_object_move_from_remote
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports moving CDMI objects from URIs within other CDMI storage systems. 
    * - cdmi_object_move_from_ID
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports moving CDMI objects without a path from a /cdmi_objectid/ URI within the same storage system. This effectively adds a path, allowing the object to be accessed by ID and by path.
    * - cdmi_object_move_to_ID
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports moving CDMI objects with a path to a /cdmi_objectid/ URI within the same storage system. This effectively removes the path, leaving the object only accessible by ID. 
    * - cdmi_object_copy_from_local
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports copying CDMI objects from URIs within the same storage system. 
    * - cdmi_object_copy_from_remote
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports copying CDMI objects from URIs within other CDMI storage systems. 
    * - cdmi_object_access_by_ID
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports accessing, updating, and deleting objects through /cdmi_objectid/. 
    * - cdmi_post_dataobject_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports adding a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_post_queue_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports adding a new queue object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_deserialize_dataobject_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports deserializating serialized data objects when creating a new data object by ID via POST to <BR>
/cdmi_objectid/. 
    * - cdmi_deserialize_queue_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports deserializating serialized queue objects when creating a new queue object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_serialize_dataobject_to_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports serializing data objects when creating a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_serialize_domain_to_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports serializing domain objects when creating a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_serialize_container_to_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system allows serializing container objects when creating a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_serialize_queue_to_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system allows serializing queue objects when creating a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_copy_dataobject_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports copying an existing data object when creating a new data object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_copy_queue_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports copying an existing queue object when creating a new queue object by ID via POST to "/cdmi_objectid/". 
    * - cdmi_create_reference_by_ID 
      - JSON String 
      - If present and "true", this capability indicates that the cloud storage system supports creating a new reference via POST to "/cdmi_objectid/". 
    * - cdmi_copy_dataobject_from_queue
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports the ability to copy to a data object from a queue object.
    * - cdmi_multipart_mime
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports storing and retrieving the value of data and queue objects using multi-part MIME.
    * - cdmi_create_value_range_by_ID
      - JSON String
      - If present and "true", this capability indicates that the system allows a new data object’s value to be created with byte ranges through "/cdmi_objectid/".

</DIV>
<DIV>

Storage System Metadata Capabilities
-----

:ref:`Capabilities for Storage System Metadata` defines the capabilities for storage system metadata in a cloud storage system. These capabilities are found in the capabilities objects for domain objects, data objects, container objects, and queue objects. See:ref:`Support for Storage System Metadata` for a description of these storage system metadata items.


.. list-table:: <A NAME="50532471_85679"></A>Capabilities for Storage System Metadata (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_acl
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports ACLs. When a CDMI implementation supports ACLs for the purpose of access control, the system-wide capability of cdmi_security_access_control specified in :ref:`Capabilities for Storage System Metadata` of :ref:`Cloud Storage System-Wide Capabilities` shall be set to "true". Otherwise, it shall not be present, indicating that there is no support for access control.
    * - cdmi_size 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_size storage system metadata for each stored object.
    * - cdmi_ctime 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_ctime storage system metadata for each stored object.
    * - cdmi_atime 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_atime storage system metadata for each stored object.
    * - cdmi_mtime 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_mtime storage system metadata for each stored object.
    * - cdmi_acount 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_acount storage system metadata for each stored object.
    * - cdmi_mcount 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_mcount storage system metadata for each stored object.

</DIV>
<DIV>

Data System Metadata Capabilities
-----

:ref:`Capabilities for Data System Metadata` defines the capabilities that indicate which data system metadata items are supported for objects stored in a cloud storage system. These capabilities are found in the capabilities objects for domains, data objects, containers, and queues. See :ref:`Support for Data System Metadata` (:ref:`Data System Metadata`) for a description of the meaning of the corresponding data system metadata items.


.. list-table:: <A NAME="50532471_73032"></A>Capabilities for Data System Metadata (Sheet 1 of 4)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_assignedsize
      - JSON String
      - When the cloud storage system supports the cdmi_assignedsize data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_assignedsize capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_assignedsize data system metadata shall not be used.
    * - cdmi_data_redundancy 
      - JSON String
      - When the cloud storage system supports the cdmi_data_redundancy data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_data_redundancy capability shall be present and set to a positive numeric string representing the maximum value that the server supports. When this capability is absent, or present and set to an empty string value "", cdmi_data_redundancy data system metadata shall not be used. 
    * - cdmi_data_dispersion 
      - JSON String
      - When the cloud storage system supports the cdmi_data_dispersion data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_data_dispersion capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_data_dispersion data system metadata shall not be used. 
    * - cdmi_data_retention 
      - JSON String
      - When the cloud storage system supports both the cdmi_retention_id and cdmi_retention_period data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_data_retention capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_retention_id and cdmi_retention_period data system metadata shall not be used. 
    * - cdmi_data_autodelete 
      - JSON String
      - When the cloud storage system supports the cdmi_data_autodelete data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_data_autodelete capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_data_autodelete data system metadata shall not be used. 
    * - cdmi_data_holds 
      - JSON String
      - When the cloud storage system supports the cdmi_hold_id data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_data_holds capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_data_holds data system metadata shall not be used. 
When a cloud storage system supports holds for the purpose of making data immutable, the system-wide capability of cdmi_security_immutability specified in :ref:`System-Wide Capabilities` of :ref:`Cloud Storage System-Wide Capabilities` shall be present and set to "true".
    * - cdmi_encryption 
      - JSON Array of JSON Strings
      - When the cloud storage system supports the cdmi_encryption data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_encryption capability shall be present and set to one or more values described in the cdmi_encryption data system metadata section in :ref:`Support for Data System Metadata`
. When this capability is absent, or present and is an empty JSON array, cdmi_encryption data system metadata shall not be used. 
When a cloud storage system supports at-rest encryption, the system-wide capability of cdmi_security_encryption specified in :ref:`System-Wide Capabilities` of :ref:`Cloud Storage System-Wide Capabilities` shall be present and set to "true".
    * - cdmi_geographic_placement
      - JSON String
      - When the cloud storage system supports the cdmi_geographic_placement data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_geographic_placement capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_geographic_placement data system metadata shall not be used. 
    * - cdmi_immediate_redundancy
      - JSON String
      - When the cloud storage system supports the cdmi_immediate_redundancy data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_immediate_redundancy capability shall be present and set to a positive numeric string representing the maximum value that the server supports. When this capability is absent, or present and set to an empty string value "", cdmi_immediate_redundancy data system metadata shall not be used. 
    * - cdmi_infrastructure_redundancy
      - JSON String
      - When the cloud storage system supports the cdmi_infrastructure_redundancy data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_infrastructure_redundancy capability shall be present and set to a positive numeric string representing the maximum value that the server supports. When this capability is absent, or present and set to an empty string value "", cdmi_infrastructure_redundancy data system metadata shall not be used. 
    * - cdmi_latency 
      - JSON String
      - When the cloud storage system supports the cdmi_latency data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_latency capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_latency data system metadata shall not be used.
    * - cdmi_RPO 
      - JSON String
      - When the cloud storage system supports the cdmi_RPO data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_RPO capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_RPO data system metadata shall not be used. 
    * - cdmi_RTO 
      - JSON String
      - When the cloud storage system supports the cdmi_RTO data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_RTO capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_RTO data system metadata shall not be used.
    * - cdmi_sanitization_method 
      - JSON Array of JSON Strings
      - When the cloud storage system supports the cdmi_sanitization_method data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_sanitization_method capability shall be present and set to one or more values described in the cdmi_sanitization_method data system metadata section in :ref:`Support for Data System Metadata`
. When this capability is absent, or present and is an empty JSON array, cdmi_sanitization_method data system metadata shall not be used. 
When a cloud storage system supports sanitization, the system-wide capability of cdmi_security_sanitization specified in :ref:`System-Wide Capabilities` of :ref:`Cloud Storage System-Wide Capabilities` shall be present and set to "true".
    * - cdmi_throughput 
      - JSON String
      - When the cloud storage system supports the cdmi_throughput data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_throughput capability shall be present and set to the string value "true". When this capability is absent, or present and set to the string value "false", cdmi_throughput data system metadata shall not be used. 
    * - cdmi_value_hash 
      - JSON Array of JSON Strings
      - When the cloud storage system supports the cdmi_value_hash data system metadata as defined in :ref:`Support for Data System Metadata`
, the cdmi_value_hash capability shall be present and set to one or more values described in the cdmi_value_hash data system metadata section in :ref:`Support for Data System Metadata`
. When this capability is absent, or present and is an empty JSON array, cdmi_value_hash data system metadata shall not be used. 
When a cloud storage system supports value hashing, the system-wide capability of cdmi_security_data_integrity specified in :ref:`System-Wide Capabilities` of :ref:`Cloud Storage System-Wide Capabilities` shall be present and set to "true". 
    * - cdmi_authentication_methods
      - JSON Array of JSON Strings
      - If present, this capability contains a list of server-supported authentication methods that are supported by a domain. The following values for authentication method strings are defined: 


        * "anonymous" - Absence of authentication supported 
        * "basic" - HTTP basic authentication supported (RFC 2617) 
        * "digest" - HTTP digest authentication supported (RFC 2617) 
        * "krb5" - Kerberos authentication supported, using the Kerberos domain specified in the CDMI domain (RFC 4559) 
        * "x509" - certificate-based authentication via TLS ( RFC 5246) 

The following values are examples of other widely used authentication methods that may be supported by a CDMI server: 


        * "s3" - S3 API signed header authentication supported 
        * "openstack" - OpenStack Identity API header authentication supported

Interoperability with these authentication methods are not defined by this international standard. 
Servers may include other authentication methods not included in the above list. In these cases, it is up to the CDMI client and CDMI server to ensure interoperability. 
When present, the cdmi_authentication_methods data system metadata shall be supported for all domains.

</DIV>
<DIV>

Data Object Capabilities
-----

:ref:`Capabilities for Data Objects` defines the capabilities for data objects in a cloud storage system.<A NAME="50532471__Ref127341260"></A>


.. list-table:: <A NAME="50532471_90914"></A>Capabilities for Data Objects (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_read_value 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the object’s value.
    * - cdmi_read_value_range 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the object’s value with byte ranges.
    * - cdmi_read_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the object’s metadata.
    * - cdmi_modify_value 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the object’s value.
    * - cdmi_modify_value_range 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the object’s value with byte ranges.
    * - cdmi_modify_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the object’s metadata.
    * - cdmi_modify_deserialize_dataobject
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the data object to deserialize a serialized data object into the data object as an update.
    * - cdmi_delete_dataobject 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to delete the object. 

</DIV>
<DIV>

Container Capabilities
-----

:ref:`Capabilities for Containers` defines the capabilities for containers in a cloud storage system.


.. list-table:: <A NAME="50532471_87821"></A>Capabilities for Containers (Sheet 1 of 3)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_list_children 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to list the container’s children.
    * - cdmi_list_children_range 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to list the container’s children with ranges.
    * - cdmi_read_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the container’s metadata.
    * - cdmi_modify_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the container’s metadata.
    * - cdmi_modify_deserialize_container
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container object to deserialize a serialized container object into the container object as an update.
    * - cdmi_snapshot 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container object to create a new snapshot.
    * - cdmi_serialize_dataobject 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to serialize a data object.
    * - cdmi_serialize_container 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to serialize the container and all children’s contents.
    * - cdmi_serialize_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to serialize a queue object.
    * - cdmi_serialize_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to serialize the domain and all child domains. 
    * - cdmi_deserialize_container
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to deserialize the serialized containers and associated serialized children into the container.
    * - cdmi_deserialize_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to deserialize the serialized queue objects into the container.
    * - cdmi_deserialize_dataobject 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to deserialize the serialized data objects into the container.
    * - cdmi_create_dataobject 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to add a new data object.
    * - cdmi_post_dataobject 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to add a new data object via POST.
    * - cdmi_post_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability of the container to add a new queue object via POST.
    * - cdmi_create_container 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to create a new container object via PUT.
    * - cdmi_create_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to create new queue objects..
    * - cdmi_create_reference 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to create a new child reference via PUT.
    * - cdmi_export_container_cifs
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to export a container as a file system via CIFS.
    * - cdmi_export_container_nfs
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to export a container as a file system via NFS.
    * - cdmi_export_container_iscsi
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to export a container as a file system via iSCSI.
    * - cdmi_export_container_occi
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to export a container as a file system via OCCI.
    * - cdmi_export_container_webdav
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to export a container as a file system via WebDAV.
    * - cdmi_delete_container 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to delete a container.
    * - cdmi_move_container 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to move a container object into a container.
    * - cdmi_copy_container 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to copy a container object into a container.
    * - cdmi_move_dataobject
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to move a data object into a container.
    * - cdmi_copy_dataobject
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to copy a data object into a container.
    * - cdmi_create_value_range
      - JSON String
      - If present and "true", this capability indicates that the container allows a new data object’s value to be created with byte ranges.

</DIV>
<DIV>

Domain Object Capabilities
-----

:ref:`Capabilities for Domain Objects` defines the capabilities for domains in a cloud storage system. (All capabilities refer to what may be done via CDMI content-type operations.  


.. list-table:: <A NAME="50532471_71774"></A>Capabilities for Domain Objects (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_create_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to add a new subdomain.
    * - cdmi_delete_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to delete a domain.
    * - cdmi_move_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to move a domain.
    * - cdmi_domain_summary
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to support domain summaries.
    * - cdmi_domain_members 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to support domain user management.
    * - cdmi_list_children 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to list the domain's children.
    * - cdmi_read_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the domain's metadata.
    * - cdmi_modify_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the domain's metadata.
    * - cdmi_modify_deserialize_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to deserialize a serialized domain object into the domain object as an update.
    * - cdmi_copy_domain 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to copy the domain (via PUT)  to another URI.
    * - cdmi_deserialize_domain
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to deserialize serialized domains and associated serialized children into the domain.

</DIV>
<DIV>

Queue Object Capabilities
-----

:ref:`Capabilities for Queue Objects` defines the capabilities for queue objects in a cloud storage system.


.. list-table:: <A NAME="50532471_34151"></A>Capabilities for Queue Objects (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Capability Name
      - Type
      - Definition
    * - cdmi_read_value 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read a queue's value.
    * - cdmi_read_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to read the queue's metadata.
    * - cdmi_modify_value 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the queue's value.
    * - cdmi_modify_metadata 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to modify the queue's metadata.
    * - cdmi_modify_deserialize_queue
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to deserialize a serialized queue into the queue as an update.
    * - cdmi_delete_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to delete a queue.
    * - cdmi_move_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to move a queue to another URI.
    * - cdmi_copy_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to copy a queue to another URI.
    * - cdmi_reference_queue 
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall support the ability to reference a queue  from another queue.

</DIV>
<DIV>

Capability Object Representations
-----

The representations in this clause are shown using JSON notation. Both clients and servers shall support UTF-8 JSON representation. The request and response body JSON fields may be specified or returned in any order, with the exception that, if present, for capability objects, the childrenrange and children fields shall appear last and in that order. 
</DIV>
</DIV>
<DIV>

Read a Capabilities Object using CDMI
************************
<DIV>

Synopsis 
-----

To read all fields from an existing capability object, the following request shall be performed:

    GET &lt;root URI&gt;/cdmi_capabilities/&lt;Capability&gt;/&lt;TheCapability&gt;/

To read one or more requested fields from an existing capability object, one of the following requests shall be performed:

    GET &lt;root URI&gt;/cdmi_capabilities/&lt;Capability&gt;/&lt;TheCapability&gt;/?&lt;fieldname&gt;;&lt;fieldname&gt;

    GET &lt;root URI&gt;/cdmi_capabilities/&lt;Capability&gt;/&lt;TheCapability&gt;/?children:&lt;range&gt; 
<DIV>
Where:


* &lt;root URI&gt; is the path to the CDMI cloud.
* &lt;Capability&gt; is zero or more intermediate capabilities containers.
* &lt;TheCapability&gt; is the name specified for the capabilities to be read from.
* &lt;fieldname&gt; is the name of a field.
* &lt;range&gt; is a numeric range within the list of children.


The object shall also be accessible at &lt;root URI&gt;/cdmi_objectid/&lt;objectID&gt;/.
</DIV>
</DIV>
<DIV>

Capability 
-----

The following capability describes the supported operations that may be performed when reading an existing capabilities object:


* All CDMI implementations shall permit clients to read all fields of all capabilities objects.

</DIV>
<DIV>

Request Headers
-----

The HTTP request headers for reading a CDMI capabilities object using CDMI are shown in :ref:`Request Headers - Read a Capabilities Object using CDMI`. 


.. list-table:: Request Headers - Read a Capabilities Object using CDMI<A NAME="50532471_17973"></A>
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Header
      - Type
      - Description
      - Requirement
    * - Accept
      - Header String
      - "application/cdmi-capability" or a consistent value as per clause :ref:`Content-Type Negotiation`
      - Optional
    * - X-CDMI-Specification-Version
      - Header String
      - A comma-separated list of versions that the client supports, e.g., "1.1, 1.5, 2.0"
      - Mandatory

</DIV>
<DIV>

Request Message Body 
-----

A request body shall not be provided.
</DIV>
<DIV>

Response Headers
-----

The HTTP response headers for reading a CDMI capabilities object using CDMI are shown in :ref:`Response Headers - Read a Capabilities Object using CDMI`.


.. list-table:: <A NAME="50532471_94894"></A>Response Headers - Read a Capabilities Object using CDMI
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Header
      - Type
      - Description
      - Requirement
    * - X-CDMI-Specification-Version
      - Header String
      - The server shall respond with the highest version supported by both the client and the server, e.g., "1.1".
If the server does not support any of the versions that the client supports, the server shall return an HTTP status code of ``400 Bad Request``
.
      - Mandatory
    * - Content-Type
      - Header String
      - "application/cdmi-capability"
      - Mandatory

</DIV>
<DIV>

Response Message Body
-----

The response message body fields for reading a CDMI capabilities object using CDMI are shown in :ref:`Response Message Body - Read a Capabilities Object using CDMI`.


.. list-table:: <A NAME="50532471_95518"></A>Response Message Body - Read a Capabilities Object using CDMI (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Field Name
      - Type
      - Description
      - Requirement
    * - objectType
      - JSON String
      - "application/cdmi-capability"
      - Mandatory
    * - objectID
      - JSON String
      - Object ID of the object
      - Mandatory
    * - objectName
      - JSON String
      - Name of the object
      - Mandatory
    * - parentURI
      - JSON String
      - URI for the parent object
      - Mandatory
    * - parentID
      - JSON String
      - Object ID of the parent container object
      - Mandatory
    * - capabilities
      - JSON Object
      - The capabilities supported by the corresponding object. Capabilities in the "/cdmi_capabilities/" object are system-wide capabilities. Capabilities found in children objects under "/cdmi_capabilities/" correspond to the capabilities of a specific subset of objects. Each capability is expressed as a JSON string.
      - Mandatory
    * - childrenrange
      - JSON String 
      - The child capabilities of the capability expressed as a range. If a range of child capabilities is requested, this field indicates the children returned as a range.
      - Mandatory
    * - children
      - JSON Array of JSON Strings
      - Names of the children capabilities objects. For the root container capabilities, this includes "domain/", "container/", "dataobject/", and "queue/". Within each of these capabilities objects, further more specialized capabilities profiles may be specified by the cloud storage system.
      - Mandatory


If individual fields are specified in the GET request, only these fields are returned in the result body. Optional fields that are requested but do not exist are omitted from the result body.
</DIV>
<DIV>

Response Status
-----

:ref:`HTTP Status Codes - Read a Capabilities Object using CDMI` describes the HTTP status codes that occur when reading a capabilities object using CDMI. 


.. list-table:: <A NAME="50532471_65427"></A>HTTP Status Codes - Read a Capabilities Object using CDMI
    :header-rows: 1
    :widths: auto
    :align: center 


    * - HTTP Status
      - Description
    * - ``200 OK``

      - The capabilities object content was returned in the response.
    * - ``400 Bad Request``

      - The request contains invalid parameters or field names.
    * - ``401 Unauthorized``

      - The authentication credentials are missing or invalid.
    * - ``403 Forbidden``

      - The client lacks the proper authorization to perform this request.
    * - ``404 Not Found``

      - The resource was not found at the specified URI.
    * - ``406 Not Acceptable``

      - The server is unable to provide the object in the content type specified in the Accept header.

</DIV>
<DIV>

Examples
-----
<DIV>
#. GET to the root container capabilities URI to read all fields of the container:

    .. code-block:: http


    GET /cdmi_capabilities/ HTTP/1.1

    Host: cloud.example.com

    Accept: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

        "objectType": "application/cdmi-capability",

        "objectID": "00007E7F00104BE66AB53A9572F9F51E",

        "objectName": "cdmi_capabilities/",

        "parentURI": "/",

        "parentID": "00007E7F0010128E42D87EE34F5A6560",

        "capabilities": {

            "cdmi_domains": "true",

            "cdmi_export_nfs": "true",

            "cdmi_export_iscsi": "true",

            "cdmi_queues": "true",

            "cdmi_notification": "true",

            "cdmi_query": "true",

            "cdmi_metadata_maxsize": "4096",

            "cdmi_metadata_maxitems": "1024"

        },

        "childrenrange": "0-3",

        "children": [

            "domain/",

            "container/",

            "dataobject/",

            "queue/"

        ]

    }
</DIV>
<DIV>
#. GET to the root container capabilities URI to read the capabilities and children of the container:

    .. code-block:: http


    GET /cdmi_capabilities/?capabilities;children HTTP/1.1

    Host: cloud.example.com

    Accept: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

        "capabilities": {

            "cdmi_domains": "true",

            "cdmi_export_nfs": "true",

            "cdmi_export_iscsi": "true",

            "cdmi_queues": "true",

            "cdmi_notification": "true",

            "cdmi_query": "true",

            "cdmi_metadata_maxsize": "4096",

            "cdmi_metadata_maxitems": "1024"

        },

        "children": [

            "domain/",

            "container/",

            "dataobject/",

            "queue/"

        ]

    }
</DIV>
<DIV>
#. GET to the root container capabilities URI to read the first two children of the container:

    .. code-block:: http


    GET /cdmi_capabilities/?childrenrange;children:0-1 HTTP/1.1

    Host: cloud.example.com

    Accept: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-capability

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

        "childrenrange" : "0-1",

        "children" : [

            "domain/",

            "container/" 

        ]

    }

&nbsp;
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532472__Toc127343509:
.. _50532472__Ref120863606:
Exported Protocols
========================================
<DIV>
.. _50532472_90582:
Overview
************************

CDMI™ containers are accessible not only via CDMI as a data path, but also via other protocols as well. This access is especially useful for using CDMI as the storage interface for a cloud computing environment, as :ref:`CDMI and OCCI in an Integrated Cloud Computing Environment` shows.


<H6 CLASS="Figure-Caption">
.. _50532472_36037:
CDMI and OCCI in an Integrated Cloud Computing Environment</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-7.gif" ALT="">
</DIV>
</TABLE>

The exported protocols from CDMI containers may be used by the virtual machines in the cloud computing environment as virtual disks on each guest as shown. The cloud computing infrastructure management is shown as implementing both an Open Cloud Computer Interface (OCCI) and CDMI interfaces. With the internal knowledge of the network and the virtual machine manager's mapping of drives, this infrastructure may associate the CDMI containers to the guests using the appropriate exported protocol. 

To support exported protocols and improve their interoperability with CDMI, CDMI provides a type of exported protocol that contains information obtained via the OCCI interface. In addition, OCCI provides a type of storage that corresponds to a CDMI container that is exported with a specific type of protocol used by OCCI. A client of both interfaces performs operations that align the architectures, including the following:


* The client creates a CDMI container through the CDMI interface and exports it as an OCCI export protocol type. The CDMI container object ID is returned as a result.
* The client creates a virtual machine through the OCCI interface and attaches a storage volume of type CDMI using the object ID and protocol type. The OCCI virtual machine ID is returned as a result.
* The client updates the export protocol structure of the CDMI container object with the OCCI virtual machine ID to allow the virtual machine access to the container.
* The client starts the virtual machine through the OCCI interface.

</DIV>
<DIV>

Exported Protocol Structure
************************

The export of a container, via data path protocols other than CDMI, is accomplished by creating or updating a container and supplying one or more export protocol structures, one for each such protocol. In this international standard, all such protocols are referred to as foreign protocols. The implementation of foreign protocols shall be indicated by "true" values for system-wide capabilities in :ref:`Cloud Storage System-Wide Capabilities` that shall always begin with "cdmi_export_".

An export protocol structure includes


* the protocol being used;
* the identity of the container as standardized by the protocol;
* the internet domain of the protocol name server for the clients being served; 
* the list of who may mount that container via that protocol, identified as standardized by that protocol or optionally by leveraging the name mapping protocol (see :ref:`Mapping Names from CDMI to Another Protocol`) and specifying CDMI user or groupnames;
* required export parameters for the protocol;
* optional export parameters for the protocol; and
* export control parameters.


This international standard defines JSON export structures for several well known foreign protocols. All depend on the following user and groupname mapping feature in the case that multi-protocol access to the container is desired. However, name mapping is not required if CDMI is used only to provision containers to be used exclusively by foreign protocols.

Implementations that support authenticated and authorized access to CDMI objects via both CDMI and foreign protocols need a way to support the setting of security on a per-object basis. The numerous methods of doing this include:


* Defining or adopting a security scheme and mapping all requests into that scheme. CDMI implementations that adopt this scheme shall use a name mapping technique to accomplish it, as (a) this mapping is easier for administrators to manage than straight id-to-id mapping, and (b) it is desired that interoperable CDMI implementations behave similarly in this respect. This means that the name of the principal in an incoming request is mapped to the name of a principal in the security domain, and that principal’s id is acquired and used in the authorization procedure.
* Allowing each protocol to set its own security, which implies that an object might be accessible to a given user via one protocol but not another.
* Using the security scheme of the last protocol that was used to set permissions on the object. This method also requires mapping the principal in the incoming request to a principal in the security domain of the object. As in the first case, the server shall use a name mapping procedure to obtain the id that is used to authorize the user against the desired object’s ACL.


CDMI does not mandate which method shall be used. It does, however, specify how users and groups shall be mapped between protocols.
<DIV>

.. _50532472_14948:
Mapping Names from CDMI to Another Protocol
-----

Clients wishing to restrict exports via foreign protocols to mounting only by certain users and groups may be required to provide user and groupname mapping information to the server. This mapping information is also required if access to the container is desired by multiple protocols, e.g., both CDMI and NFS. The mapping is done as follows.
<OL>
#. When a network share on a CDMI container is created, the server should use the appropriate mechanism, e.g., Powershell WmiClass.Create( ) on the Windows platform or /etc/exports on Unix, to limit permitted mounts of the share from other servers, as specified in the "hosts" line of the "exports" property. The syntax of the hosts line follows the syntax of /etc/exports in the Linux operating system, as encoded in a JSON string. If the CDMI server is unable to limit mounts as specified by the hosts line, an error shall result, but the success or failure of the operation depends on the implementation.
#. When any request requiring the use of a CDMI principal name comes in via a foreign protocol, the foreign domain controller to which the foreign server belongs shall be queried for the principal name corresponding to the user id given in the request. Failure to procure the principal name shall cause the original request to fail.
#. The usermap list for that protocol shall be searched, in order, for an entry matching the username gotten from the foreign domain controller (see :ref:`User and Groupname Mapping Syntax and Evaluation Rules`  for details on the search). If no match is found, the request shall be denied. The search results may be kept in the same cache entry as the information from the preceding step.
#. The CDMI principal name gotten from the first matching usermap entry during this search is then used to authorize the user request via the security mechanism of the protocol whose security governs access to the object.
</OL>
<DIV>
<H6 CLASS="H4">
Capabilities</H6>

The following capabilities describe the supported operations that can be performed on an existing container:


* The system-wide capability to export via a given protocol is indicated by the cdmi_&lt;protocol&gt;_export capability in the system-level metadata (e.g., "cdmi_nfs_export", when set to "true", indicates the ability of the system to export containers via NFS). If false or not set, attempts to export containers via the given protocol shall fail.
* Support for the ability to export an existing container object via a given foreign protocol is indicated by the cdmi_&lt;protocol&gt;_export capability in the specified container. The default shall be "true" if this capability is unset.

</DIV>
<DIV>
<H6 CLASS="H4">
Domains</H6>

The internet domain name corresponding to each export shall be given as a JSON-formatted string in the "domain" child of the protocol export specification. If it is not present, it shall be assumed that the domain is the same as that of the server hosting the CDMI implementation.
</DIV>
<DIV>
<H6 CLASS="H4">
Caching</H6>

The lookup to a foreign domain controller can be quite expensive, especially for stateless protocols such as NFS v3, in which it can be theoretically required for nearly every operation. It shall be permissible to cache the results of this lookup. The recommended lifetime of a username cache entry is 30 minutes. Implementations should use this value or less when possible. Servers shall flush this cache whenever a change is made to the exports metadata concerning the protocol being cached. A client may request that the cache be flushed by reading in the usermap data for one or more protocols and writing them back without change. Servers shall flush their username mapping caches, as part of the rewrite operation, for any protocol for which the usermap information has been changed or reset.

For authorization by group to operate via a foreign protocol, a similar mapping exercise must be performed. Multiple lookups to the foreign domain controller may be required to get all the groupnames for a given user (e.g., it is common for an NFS user to be a member of several groups). A groupname cache may be used to mitigate the cost of these lookups. The recommended lifetime of a groupname cache entry is 12 hours. Implementations should use this value or less when possible. Clients may force a flush of the cache by reading in and resetting the group map information. Servers shall immediately flush their groupname mapping cache, as part of the rewrite operation, for any protocol for which the group map information has been changed or reset.
</DIV>
<DIV>
<H6 CLASS="H4">
Groups</H6>

Groupname mapping for each foreign protocol shall be specified in a groupname field of the foreign protocol export specification. Its syntax is identical to the syntax for the username field.
<DIV>
<H6 CLASS="Note">
The mapping information is only required on the container being exported.</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="H4">
Synopsis</H6>

    PUT /MyContainer HTTP/1.1

    Host: cloud.example.com

    Accept: application/cdmi-container

    Content-Type: application/cdmi-container

    X-CDMI-Specification-Version: 1.0

    &nbsp;

    {

        "exports" : {

            "nfs" : {<BR>
         "hosts" : { "*.mycollege.edu", "derf.cs.myuni.edu" },

                "domain" : "lab.mycollege.edu",

                "usermap" : {

                    { &lt;cdminame&gt;, &lt;map&gt;, &lt;nfsname&gt; },

                    { "jimsmith", "&lt;--&gt;", "jims" },

                    { [ordered list of CDMIname/operator/NFSname triples] },

                    { "*", "&lt;--&gt;", "*" }

                }

                "groupmap" : {

                    { "admins", "&lt;-", "wheel" },

                    { "everyone", "&lt;-", "*" }

                }

            }

            "cifs" : {

                "hosts" : "*",

                "domain" : "lab.mycollege.edu",

                "usermap" : {

                    { "jimsmith", "&lt;--&gt;", "james.smith" }

                    { [ordered list of CDMIname/operator/NFSname triples] },

                    { "*", "&lt;--&gt;", "*" }

                }

                "groupmap" : {

                    { "admins", "&lt;-", "Administrators" },

                    { "everyone", "&lt;-", "*" }

                }

            }

        }

    }

   The following shows the response. 

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-container

    X-CDMI-Specification-Version: 1.0

    &nbsp;

    {

        "objectURI" : "/Containers/MyContainer/",

        "objectID" : "00007E7F00100C435125A61B4C289455",

        "objectName" : "MyContainer/",

        "parentURI" : "/Containers/",

        "parentID" : "00007E7F0010D538DEEE8E38399E2815",

        "domainURI" : "/cdmi_domains/MyDomain/",

        "capabilitiesURI" : "/cdmi_capabilities/container/",

        "completionStatus" : "Complete",

        "metadata" : { 

    			... 

    		},

        "exports" : { &lt;exports as listed in request&gt; }

    }
</DIV>
</DIV>
<DIV>

Administrative Users
-----

By default, the following users shall be considered "root", or administrative users, and equivalent to each other: 


* root (Unix/NFS/LDAP),
* Administrator (Windows/AD/CIFS), and 
* the domain owner (CDMI). 


Servers shall automatically map these users to the root user of the target protocol unless otherwise instructed by the usermaps. 

As an automatic mapping does not meet strict security standards, servers shall override these built-in entries with any usermap entries that apply to one or more root users. 
<DIV>
<H6 CLASS="Example">
In the following example, root gets mapped to nobody, and everyone else is mapped to a user of the same name in the NFS domain and the CDMI domain.</H6>

    PUT /MyContainer HTTP/1.1

    Host: cloud.example.com

    Accept: application/vnd.org.snia.cdmi.container+json

    Content-Type: application/vnd.org.snia.cdmi.container+json

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

        "exports": {

            "nfs": {

                "usermap": [

                    [

                        "nobody",

                        "&lt;-",

                        "root"

                    ],

                    [

                        "*",

                        "&lt;--&gt;",

                        "*"

                    ]

                ]

            }

        }

    }
</DIV>
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
Permissions Mapping</H6>

The permissions sets of file-serving protocols, unfortunately, do not map on a one-to-one basis to each other. NFSv4 ACLs, Windows ACLs, POSIX ACLs, NFSv3 perms and object-based capabilities all are capable of representing security conditions that the others are not, except NFSv3, which is the least expressive. The primary area of concern is in representing the possibly rich set of permissions in a CDMI ACL in a more restricted perms-based system, such as NFSv3, for display to users. 

As there are a number of possible ways to coordinate the permissions/ACLs and CDMI ACLs, this international specification does not mandate a particular method. However, all mappings of user and groupnames between domains shall use the name mapping mechanism specified in :ref:`User and Groupname Mapping Syntax and Evaluation Rules`.
<DIV>

.. _50532472_97905:
User and Groupname Mapping Syntax and Evaluation Rules
-----

A BNF-style grammar for name mapping is as follows:

   name_mapping_list = protocol protocol mapping_list

   protocol = "cdmi" | "nfs" | "cifs" | "ldap" 

   mapping_list = name mapping_operator name

   name = pattern | utf8_name | quoted_utf8_name

   quoted_utf8_name = " utf8_name "

   utf8_name = &lt;any legal utf8 character sequence not including the characters ",',\,/,:,*,?&gt;

   pattern =  &lt;utf8_name&gt; * | *

   mapping_operator = "&lt;--" | "&lt;--&gt;" | "--&gt;"

To restate this in English, a mapping entry consists of two names separated by a directional indicator. As most environments use the same usernames and groupnames across administrative domains, the most common mapping is " * &lt;--&gt; * ", which maps any name to the same name in the foreign protocol domain, and vice versa. It is highly recommended that this be both the default map and the last entry on all more complex maps.

CDMI specifies pattern matching on names in the name map, but only prefix matching is required. The symbol " * " at the end of a character string shall match zero or more occurrences of any non-whitespace character.

Evaluation of the name mapping list shall proceed in order; once a match is made, evaluation shall cease and the result of the match shall be returned.

If no matches are found on the match list, the result is system dependent. However, it is recommended that servers either deny access altogether or map the user in question to the equivalent of "anonymous" on the destination protocol. It is also recommended that an entry be devoted to the special user "EVERYONE@".
</DIV>
</DIV>
</DIV>
<DIV>

Discovering and Mounting Containers via Foreign Protocols
************************

Clients need a way to discover exported containers that may be available for mounting. Discovering containers is done via a GET operation to the "exports" member of a container. 
<DIV>
<H6 CLASS="Body-Text-Head">
Synopsis: </H6>

To read all exports for an existing container object, the following request shall be performed:

    GET &lt;root URI&gt;/&lt;ContainerName&gt;/&lt;TheContainerName&gt;/?exports

To read selected exports for an existing container object, the following request shall be performed:

    GET &lt;root URI&gt;/&lt;ContainerName&gt;/&lt;TheContainerName&gt;/?exports:protocol=&lt;protocol&gt;,user=&lt;user&gt;,verbose="false"
<DIV>
Where:


* &lt;root URI&gt; is the path to the CDMI cloud.
* &lt;ContainerName&gt; is zero or more intermediate containers.
* &lt;TheContainerName&gt; is the name specified for the topmost container for which exports are available.
* &lt;protocol&gt; is the name of a protocol to which query results should be restricted. This parameter is optional; if it is omitted or a value of "all" is given, information about all protocols shall be returned, subject to additional filtering.
* &lt;user&gt; is the login name of a CDMI user who wishes to mount the share. This parameter is optional and defaults to the owner of the container. When non-empty, servers shall filter the returned export list to include only exports which may be mounted given the restrictions in the protocol export structures.
* &lt;verbose&gt; is an optional parameter indicating a desire for maximum information about the exports. When present, it shall have the values "true" or "false". The default is "false". When true, the server should return additional information about the container, as contained in its "exports" member. The amount of said information that is returned is implementation dependent, as server implementors need to be able to balance the needs of their clients against various security considerations.

</DIV>
</DIV>
</DIV>
<DIV>
.. _50532472_64565:
NFS Exported Protocol
************************

To export a container via NFS, the information required is exactly what the server implementation will use to do the export. Normally, this information is contained in the /etc/exports file on a server or the equivalent. Administrators should be aware that lines may be automatically added to that file for each CDMI container that is exported.

Required members of the protocol structure for NFS are described in :ref:`Required Members of the NFS Protocol Structure`.


.. list-table:: <A NAME="50532472_31650"></A>Required Members of the NFS Protocol Structure  
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Member
      - Description
    * - protocol
      - The protocol being requested. This value shall be "NFSv3", "NFSv4", "NFSv4.1", or any subsequent NFS version enshrined in a major IETF RFC. Version 2 of NFS is not supported by CDMI.
    * - exportpath
      - The pathname to which the export should be surfaced. This value shall be a UTF8 string of the form [&lt;server&gt;]:/&lt;path&gt;, where the &lt;server&gt; component is optional, (e.g., "eeserver:/lessons/number1"). The &lt;server&gt; component of the path must be obtained from an administrator of the service running the CDMI implementation.
    * - exportdomain
      - The internet domain of the protocol name server for the clients being served. This value is normally the name of the LDAP domain for the organization, e.g., "iti.edu". A value of "." shall be interpreted to be the DNS name of the domain occupied by the CDMI server.
    * - mode
      - This value shall be "ro", "rw", "root" or "rpc_gsssec" and becomes the default export mode. Hosts requiring different access shall be specified in the optional "rw_mode", "ro_mode", and "root_mode" structure members. However, the "rpc_gsssec" mode overrides all other modes, and all other mode members and their contents shall be ignored if it is specified.
    * - control
      - Export control for the container. This value shall be "immediate", "off", "on", or &lt;n&gt; (a number). Servers may set the value to on, but clients shall not. A numeric value (&lt;n&gt;) indicates that the export should be shut down in &lt;n&gt; seconds, possibly after a message has been sent to clients mounting the export. If a client specifies a value for &lt;n&gt; but the server does not support delayed shutdown of exports, then &lt;n&gt; shall be interpreted to mean off.


Optional export parameters for NFS are described in :ref:`Optional NFS Export Parameters`.


.. list-table:: <A NAME="50532472_69455"></A>Optional NFS Export Parameters 
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Parameter
      - Description
    * - domain_servers
      - A list of server names or IP addresses that function as name servers for the domain given in "domain". If given, this list shall override the names obtainable by the CDMI server via other programmatic means.
    * - mount_name
      - The name the client should use to surface the export. This name replaces the last name in the path string, (e.g., mounting "eeserver:/lessons/number1" with a mountname of "1" over the directory /somepath/lessons/num1 should result in a /somepath/lessons/1 directory on the client).
    * - hosts
      - A list of hosts that can access the container in the mode given in "mode". The default shall be "*"; other values restrict the possibilities.
    * - root_hosts
      - A list of hosts that can access the container in superuser mode. The default shall be an empty list.
    * - rw_hosts
      - A list of hosts that can access the container in r/w mode. The default shall be an empty list.
    * - ro_hosts
      - A list of hosts that can access the container in r/o mode only. The default shall be an empty list.
    * - mount_type
      - One of the two strings "hard" or "soft". Clients hang when a server serving a hard mount becomes unresponsive. Clients with soft mounts generate error messages. The default is implementation dependent.
    * - recurse
      - This value shall be either "true" or "false". The default shall be "true". When true, recurse indicates that mounts within the CDMI directory structure (presumably put there by other NFS operations) shall be followed and the mounted directory exposed as though it were part of the CDMI container actually being exported. This parameter is equivalent to the Linux "crossmnt" parameter.


Other export parameters for NFS are not specified by the CDMI protocol but may be included in the export structure. These parameters include Linuxisms, such as "sync", "no_wdelay", "insecure_locks", and "no_acl", as well as any other parameters used by a given server operating system.  In all such cases, the parameter shall be specified as a JSON tuple in which "true" and "false" are explicitly called out for binary flags, and a JSON-formatted string or list is used for other parameters. 
<DIV>
<H6 CLASS="Example">
&nbsp;</H6>

    ``{ "exports" ``

    ``		{ "nfs" ``

    ``			{<BR>
				...<BR>
				{"no_wdelay", "true" },<BR>
				{"refer", "otherserver://path/leaf"},``

    ``				...``

    ``			}``

    ``		}``

    ``	}`` 
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
.. _50532472_69035:
Export Control</H6>

Export control is accomplished with the use of a single member, named "control":


* The value "immediate" shall indicate to the server that the export shall be made successfully before the PUT operation returns. Servers shall reset the value to "on" and place that in the reply.
* The value "off" shall indicate to the server that the export, if new, shall not be enabled, and if existing, shall be shut down and all client connections forcibly broken.
* A numeric value &lt;n&gt; shall indicate that the server shall wait &lt;n&gt; seconds before forcibly shutting down the export and breaking client connections. Whether the server sends a warning message to clients, giving them a chance to exit from the connection gracefully, is recommended but implementation dependent. Once the export has been shut down, the server shall also change the value of  "control" to "off" in the export structure.


Servers shall support wildcard matching on the " * " and " ? " characters in the hosts lists (this is standard practice), so that **.cs.uscs.edu" matches all servers in the cs.ucsc.edu department.

Servers may support netgroup names in the various hosts lists. When this functionality is supported, these names shall resolve to ordinary lists of hostnames via queries to the domain nameserver.

Servers may also support IP address ranges in the various lists of hosts. These IP addresses shall beaugmented by the same wildcard matching as is used for ordinary host names (e.g., "192.168.1.*" exports to all the machines on a default home network). Client-side developers should note that "exporting to" only means making a container available for export. The client must still mount the exported container before there is a connection with the server.

Users wishing to use optional and vendor-specific settings are responsible for determining from the CDMI product vendor the legal settings and their format. Servers shall return an HTTP status code of ``400 Bad Request`` when an export setting does not conform to an allowable setting on the server.
</DIV>
</DIV>
<DIV>

CIFS Exported Protocol
************************

To export a container via CIFS, the information required is exactly what the server implementation will use to do the export. Where this information is contained on a server is implementation dependent. The server may add or delete lines automatically to and from that file for each CDMI container that is exported or unexported.

Required members of the protocol structure for CIFS are described in :ref:`Required Members of the CIFS Protocol Structure`.


.. list-table:: <A NAME="50532472_85536"></A>Required Members of the CIFS Protocol Structure
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Member
      - Description
    * - share_name
      - The name that CIFS shall use to discover the share.
    * - exportdomain
      - The domain of the protocol name server for the clients being served. This value is normally the name of the Active Directory LDAP domain for the organization, e.g. "iti.edu". A value of "." shall be interpreted to be the domain occupied by the CDMI server.
    * - mode
      - This value shall be either "ro" or "rw".
    * - control
      - Export control for the container. This value shall be "immediate", "off", or &lt;n&gt; (a number). Servers may set the value to on, but clients shall not. The semantics and normative requirements are exactly the same as for NFS, as documented in the paragraph ":ref:`Export Control`" in the subclause on NFS Exports (see :ref:`NFS Exported Protocol`).


There is no protocol specification; CDMI assumes that normal SMB protocol negotiation will take place. 

An optional export parameter is "comment," which is often used as a user-friendly share name on the client.

Other export parameters for CIFS are not specified by the CDMI protocol but may be included in the export structure. These parameters include vendor settings such as "forcegroup", "umask", "caching", and "oplocks", as well as any other parameters used by a given server operating system.  In all such cases, the parameter shall be specified as a JSON tuple in which "true" and "false" are explicitly called out for binary flags, and a JSON-formatted string or list is used for other parameters. 
<DIV>
<H6 CLASS="Example">
 &nbsp;</H6>

    ``{ "exports" ``

    ``		{ "cifs" ``

    ``			{<BR>
				...<BR>
				{"caching", { "manual", "document", "program" },<BR>
				{"oplocks", "true"},``

    ``				...``

    ``			}``

    ``		}``

    ``	}``	

Users wishing to manipulate vendor-specific settings are responsible for determining from the CDMI product vendor the legal settings and their format. Servers shall return an HTTP status code of ``400 Bad Request`` when an export setting does not conform to an allowable setting on the server.

For more detail on the use of the OCCI export protocol structure attributes, see :ref:`Overview`. Because the actual networking and access control is under the control of a hidden, common infrastructure implementing both OCCI and CDMI, the normal permission structure shall not be provided.
</DIV>
</DIV>
<DIV>

OCCI Exported Protocol
************************

CDMI defines an export protocol structure for the Open Cloud Computing Interface (:ref:`OCCI`) as follows:


* The protocol is "OCCI/&lt;protocol standard&gt;" (e.g., "OCCI/NFSv4").
* The identifier is the CDMI object ID.
* A JSON array of URIs to OCCI compute resources shall have access (permissions) to the exported container.

<DIV>
<H6 CLASS="Example">
An example of an OCCI export protocol structure in JSON is as follows:</H6>

    "OCCI/iSCSI": {

            "identifier": "00007E7F00104BE66AB53A9572F9F51E",

            "permissions": [

                "http://example.com/compute/0/",

                "http://example.com/compute/1/"

            ]

        }

For more detail on using the OCCI export protocol structure attributes, see :ref:`Overview`. Because the actual networking and access control is under the control of a hidden, common infrastructure that implements both OCCI and CDMI, the normal permission structure shall not be provided.
</DIV>
</DIV>
<DIV>

iSCSI Export Modifications
************************

CDMI defines the export of a container using the iSCSI protocol (see :rfc:`3720`). Each container is exported as a single SCSI Logical Unit as a Logical Unit Number (LUN). One or more iSCSI initiators import the LUN through an iSCSI target node and port using one or more iSCSI network portals (IP addresses). 

The export is described by the presence of an export field structure on the container that specifies the


* export protocol ("Network/iSCSI");
* iSCSI target information (IP addresses or fully qualified domain names, target identifier, and LUN);
* logical unit world-wide name; and
* iSCSI initiators having access.


The target identifier may be in iqn, naa, or eui format and shall have the target portal group tag appended in hexadecimal.
<DIV>

Read Container
-----

All of the information in the export structure is returned:

    "exports" : 

    {

        "Network/iSCSI": {

            "portals": [

                "192.168.1.101",

                "192.168.1.102"

            ],

            "target_identifier": "iqn.2010-01.com.cloudprovider:acmeroot.container1,t,0x0001",

            "logical_unit_number": "3",

            "logical_unit_name": "0x60012340000000000000000000000001",

            "permissions": [

                "iqn.2010-01.com.acme:host1",

                "iqn.2010-01.com.acme:host2"

            ]

        }

    } 
</DIV>
<DIV>

Create and Update Containers
-----

The following export field contents, when included in a container create or update, indicates that the container shall be exported via iSCSI. Support for either of these operations is indicated by the cdmi_export_iscsi capability on the parent container of the created container or of the existing container, respectively.

    "exports" : 

    {

        "Network/iSCSI": {

            "permissions": [

                "iqn.2010-01.com.acme:host1",

                "iqn.2010-01.com.acme:host2"

            ]

        }

    }

For these export creation operations, the CDMI implementation selects the IP portals, iSCSI target, logical unit number, and logical unit name; these are not supplied. Only the list of initiator identifiers that are to have access to the container are specified.
</DIV>
<DIV>

Modify an Export
-----

The following code modifies an export on an existing container. Support for this operation is indicated by the cdmi_export_iscsi on the parent container of the existing container. For this operation, only the current list of initiator identifiers that are to have access to the container are specified.

    "exports" : 

    {

        "Network/iSCSI": {

            "permissions": [

                "iqn.2010-01.com.acme:host2"

            ]

        }

    }
</DIV>
</DIV>
<DIV>

 WebDAV Exported Protocol
************************

CDMI defines an export protocol structure for the WebDAV standard as follows (see 
:rfc:`4918`)
: 


* The protocol is "Network/WebDAV".
* The path of the WebDAV mount point is as presented to clients (including server host name).
* The list of who may access the share is determined by the standard CDMI ACLs for each resource as exported via WebDAV.

<DIV>
<H6 CLASS="Example">
The following example shows a WebDAV export protocol structure in JSON: </H6>

    "Network/WebDAV" : 

    {

        "identifier": "/users",

        "permissions": "domain"

    } 

In this example, the value "domain" in the permissions field indicates that user credentials should be mapped through the domain membership in the domain of the CDMI container being exported. 

WebDAV supports locking, but it is up to implementations to support any locking of access through CDMI as a result, and the interaction between the two protocols is purposely not described in this international standard. 
</DIV>
</DIV>
</DIV>
<DIV>
CDMI <A NAME="50532473__Ref120863623"></A>Snapshots
========================================

A snapshot is a point-in-time copy (image) of a container and all of its contents, including subcontainers and all data objects and queue objects. The client names a snapshot of a container at the time the snapshot is requested. A snapshot operation creates a new container to contain the point-in-time image. The first processing of a snapshot operation also adds a cdmi_snapshots child container to the source container. Each new snapshot container is added as a child of the cdmi_snapshots container. The snapshot does not include the cdmi_snapshots child container or its contents (see :ref:`Snapshot Container Structure`).


<H6 CLASS="Figure-Caption">
.. _50532473_94097:
Snapshot Container Structure</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-8.gif" ALT="">
</DIV>
</TABLE>

A snapshot operation is requested using the container update operation (see :ref:`Update a Container Object using CDMI`), in which the snapshot field specifies the requested name of the snapshot.

A snapshot may be accessed in the same way that any other CDMI™ object is accessed. An important use of a snapshot is to allow the contents of the source container to be restored to their values at a previous point in time using a CDMI copy operation. 

&nbsp;
</DIV>
<DIV>
.. _50532474__Toc127343516:
.. _50532474__Ref120863640:
Serialization/Deserialization
========================================
<DIV>

Overview
************************

Occasionally, bulk data movement is needed between, into, or out of clouds. When moving bulk data, cloud serialization operations provide a means to normalize data to a canonical, self-describing format, which includes:


* data migration between clouds,
* data migration during upgrades (or replacements) of cloud implementations, and
* robust backup.


The canonical format of serialized data describes how the data is to be represented in a byte stream. As long as this byte stream is not changed during the transfer from source to destination, the data may be reconstituted on the destination system.
</DIV>
<DIV>

Exporting Serialized Data
************************

A canonical encoding of the data is obtained by creating a new data object and specifying that the source for the creation is to serialize a given CDMI™ data object, container object, or queue object. On a successful serialization, the result shall be a data object that is created with the serialized data as its value. If a container object has an exported block protocol, the serialized data may contain the block-by-block contents of that container object along with its metadata.

The resulting data object that is produced is the canonical representation of the selected data object, container object and children, or queue object. 


* If the source specified is a data object, the canonical format shall contain all data object fields, including the value, valuetransferencoding, and metadata fields. 
* If the source being specified is a queue object, the canonical format shall contain all queue object fields, including the value and valuetransferencoding fields of enqueued items, along with the metadata of the queue object itself. 
* If the source being specified is a container object, the canonical format shall contain all container object fields, recursively, including all children of the container object. If a user attempts to serialize a container object that includes children that the user, who is performing the serialization operation, does not have permission to read, these objects shall not be included in the resulting serialized object.


When performing a serialization operation, objects shall only be included if the principal initiating the serialization has sufficient permissions to read those objects.
</DIV>
<DIV>

Importing Serialized Data
************************

Canonical data may be deserialized back into the cloud by creating a new data object, container object, or queue object and by specifying that the source for the creation is to deserialize a given CDMI data object or by specifying the serialized data in base 64 encoding in the deserializevalue field.

The destination may or may not exist previously. If not, a create operation is performed. If a container object already exists, an update operation with serialized children shall update the container object and all children. If the serialized container object does not contain children, only the container object is updated. Data objects are recreated as specified in the canonical format, including all metadata and the data object ID.


* If the user who is deserializing a serialized data object has the cross_domain privilege and has not specified a domainURI as part of the deserialize operation, the original domainURIs from the serialized object shall be used. If any of the specified domainURIs are not valid in the context of the storage system on which the deserialization operation is being performed, the entire deserialize operation shall fail.
* If the user who is deserializing a serialized object specifies a domainURI as part of the deserialize operation, the domainURI of every object being deserialized shall be set to the specified domainURI. To specify a domainURI other than the domainURI of the parent, the user shall have the cross_domain privilege. If the user does not have the cross_domain privilege and specifies a domainURI other than the domainURI of the parent, an HTTP status code of ``400 Bad Request`` shall be returned.
* If the user who is deserializing a serialized object does not specify a domainURI and does not have the cross_domain privilege, then the deserialization operation shall only be successful if all objects have the same domainURI as the parent object on which the deserialization operation is being performed.


Deserialization operations shall restore all metadata from the specified source. If the original provider of the serialized data-supported vendor extensions is through custom metadata keys and values, then these customized requirements shall be restored when deserialized. However, the custom metadata keys and values may be treated as user metadata (preserved, but not interpreted) by the destination provider. Preservation allows custom data requirements to move between clouds without losing this information.
<DIV>

Canonical Format
-----

The canonical format shall represent specified data objects and container objects as they exist within the storage system. Each object shall be represented by the metadata for the object, identifiers, and the data stream contents of the data object. Because metadata is inherited from enclosing container objects, all parent metadata shall be represented in the canonical format (essentially flattening the hierarchy). To preserve the actual metadata values that apply to the data object that is being serialized, the non-overridden metadata is included from both the immediate parent container object of the specified object and from the parent of each higher-level container object. 

The canonical format shall have the following characteristics:


* recursive JSON for the data object, consistent with the rest of CDMI;
* user and data system metadata for each data object/container object; 
* data stream contents for each data object and queue object; 
* binary data represented using escaped JSON strings; and 
* typing of data values consistent with CDMI JSON representations. 

</DIV>
<DIV>

Example JSON Canonical Serialized Format
-----
<DIV>
<H6 CLASS="Example">
In this example, a data object and a queue object in a container object have been selected for serialization:</H6>

    {

        "objectType": "application/cdmi-container",

        "objectID": "00007E7F00102E230ED82694DAA975D2",

        "objectName": "MyContainer/",

        "parentURI": "/",

        "parentID": "00007E7F0010128E42D87EE34F5A6560",

        "domainURI": "/cdmi_domains/MyDomain/",

        "capabilitiesURI": "/cdmi_capabilities/container/",

        "completionStatus": "Complete",

        "metadata": {

    				...

    		},

        "exports": {

            "OCCI/iSCSI": {

                "identifier": "00007E7F00104BE66AB53A9572F9F51E",

                "permissions": [

                    "http://example.com/compute/0/",

                    "http://example.com/compute/1/"

                ]

            },

            "Network/NFSv4": {

                "identifier": "/users",

                "permissions": "domain"

            }

        },

        "childrenrange": "0-1",

        "children": [

            {

                "objectType": "application/cdmi-object",

                "objectID": "00007ED900104F67307652BAC9A37C93",

                "objectName": "MyDataObject.txt",

                "parentURI": "/MyContainer/",

                "parentID": "00007E7F00102E230ED82694DAA975D2",

                "domainURI": "/cdmi_domains/MyDomain/",

                "capabilitiesURI": "/cdmi_capabilities/dataobject/",

                "completionStatus": "Complete",

                "mimetype": "text/plain",

                "metadata": {

    								...

    						},

                "valuerange": "0-36",

                "valuetransferencoding": "utf-8",

                "value": "This is the Value of this Data Object"

            },

            {

                "objectType": "application/cdmi-queue",

                "objectID": "00007E7F00104BE66AB53A9572F9F51E",

                "objectName": "MyQueue",

                "parentURI": "/MyContainer/",

                "parentID": "00007E7F00102E230ED82694DAA975D2",

                "domainURI": "/cdmi_domains/MyDomain/",

                "capabilitiesURI": "/cdmi_capabilities/queue/",

                "completionStatus": "Complete",

                "metadata": {

    								...

    						},

                "queueValues": "0-1",

                "mimetype": [

                    "text/plain",

                    "text/plain"

                ],

                "valuetransferencoding": [

                    "utf-8",

                    "utf-8"

                ],

                "valuerange": [

                    "0-2",

                    "0-3"

                ],

                "value": [

                    "red",

                    "blue"

                ]

            }

        ]

    }

To allow efficient deserialization in stream mode when serializing container objects to JSON, the children array should be the last item in the canonical serialized JSON format.
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532475__Toc127343522:
.. _50532475__Ref114042872:
<A NAME="50532475__Ref114041211"></A><A NAME="50532475__Ref114028977"></A><A NAME="50532475__Ref113958744"></A><A NAME="50532475__Ref113958733"></A>Metadata
========================================
<DIV>

Access Control
************************

Access control comprises the mechanisms by which various types of access to objects are authorized and permitted or denied. CDMI™ uses the well-known mechanism of an Access Control List (ACL) as defined in the NFSv4 standard (see :rfc:`3530`). ACLs are lists of permissions-granting or permissions-denying entries called access control entries (ACEs). 
<DIV>

ACL and ACE Structure
-----

An ACL is an ordered list of ACEs. The two types of ACEs in CDMI are ALLOW and DENY. An ALLOW ACE grants some form of access to a principal. Principals are either users or groups and are represented by identifiers. A DENY ACE denies access of some kind to a principal. For instance, a DENY ACE may deny the ability to write the metadata or ACL of an object but may remain silent on other forms of access. In that case, if another ACE ALLOWs write access to the object, the principal is allowed to write the object's data, but nothing else. 

ACEs are composed of four fields: type, who, flags and access_mask, as per :rfc:`3530`. The type, flags, and access_mask shall be specified as either unsigned integers in hex string representation or as a comma-delimited list of bit mask string form values taken from :ref:`ACE Types`, :ref:`ACE Flags`, and :ref:`ACE Bit Masks`.
</DIV>
<DIV>

ACE Types
-----

:ref:`ACE Types` defines the following ACE types, following NFSv4.


.. list-table:: <A NAME="50532475_48944"></A>ACE Types
    :header-rows: 1
    :widths: auto
    :align: center 


    * - String Form
      - Description
      - Constant
      - Bit Mask
    * - "ALLOW"
      - Allow access rights for a principal
      - CDMI_ACE_ACCESS_ALLOW
      - 0x00000000
    * - "DENY"
      - Deny access rights for a principal
      - CDMI_ACE_ACCESS_DENY
      - 0x00000001
    * - "AUDIT"
      - Generate an audit record when the principal attempts to exercise the specified access rights
      - CDMI_ACE_SYSTEM_AUDIT
      - 0x00000002

<DIV>
<H6 CLASS="Note">
The reason that the string forms may be safely abbreviated is that they are local to the ACE structure type, as opposed to constants, which are relatively global in scope.</H6>

The client is responsible for ordering the ACEs in an ACL. The server shall not enforce any ordering and shall store and evaluate the ACEs in the order given by the client.
</DIV>
</DIV>
<DIV>

ACE Who
-----

The special "who" identifiers need to be understood universally, rather than in the context of a particular external security domain (see :ref:`Who Identifiers`). Some of these identifiers may not be understood when a CDMI client accesses the server, but they may have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over CDMI, even if none of the access methods on the server understands the identifiers.<A NAME="50532475__Ref121024292"></A>


.. list-table:: <A NAME="50532475_69848"></A>Who Identifiers
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Who
      - Description
    * - "OWNER@"
      - The owner of the file
    * - "GROUP@"
      - The group associated with the file
    * - "EVERYONE@"
      - The world
    * - "ANONYMOUS@"
      - Access without authentication
    * - "AUTHENTICATED@"
      - Any authenticated user (opposite of ANONYMOUS)
    * - "ADMINISTRATOR@"
      - A user with administrative status, e.g., root
    * - "ADMINUSERS@"
      - A group whose members are given administrative status


To avoid name conflicts, these special identifiers are distinguished by an appended "@" (with no domain name).
</DIV>
<DIV>

ACE Flags
-----

CDMI allows for nested containers and mandates that objects and subcontainers be able to inherit access permissions from their parent containers. However, it is not enough to simply inherit all permissions from the parent; it might be desirable, for example, to have different default permissions on child objects and subcontainers of a given container. The flags in :ref:`ACE Flags` govern this behavior. 


.. list-table:: <A NAME="50532475_83722"></A>ACE Flags 
    :header-rows: 1
    :widths: auto
    :align: center 


    * - String Form
      - Description
      - Constant
      - Bit Mask
    * - "NO_FLAGS"
      - No flags are set
      - CDMI_ACE_FLAGS_NONE
      - 0x00000000
    * - "OBJECT_INHERIT"
      - An ACE on which OBJECT_INHERIT is set is inherited by objects as an effective ACE: OBJECT_INHERIT is cleared on the child object. When the ACE is inherited by a container, OBJECT_INHERIT is retained for the purpose of inheritance, and additionally, INHERIT_ONLY is set. 
      - CDMI_ACE_FLAGS_OBJECT_INHERIT_ACE
      - 0x00000001
    * - "CONTAINER_INHERIT"
      - An ACE on which CONTAINER_INHERIT is set is inherited by a subcontainer as an effective ACE. Both INHERIT_ONLY and CONTAINER_INHERIT are cleared on the child container. 
      - CDMI_ACE_FLAGS_CONTAINER_INHERIT_ACE
      - 0x00000002
    * - "NO_PROPAGATE"
      - An ACE on which NO_PROPAGATE is set is not inherited by any objects or subcontainers. It applies only to the container on which it is set. 
      - CDMI_ACE_FLAGS_NO_PROPAGATE_ACE
      - 0x00000004
    * - "INHERIT_ONLY"
      - An ACE on which INHERIT_ONLY is set is propagated to children during ACL inheritance as specified by OBJECT_INHERIT and CONTAINER_INHERIT. The ACE is ignored when evaluating access to the container on which it is set and is always ignored when set on objects. 
      - CDMI_ACE_FLAGS_INHERIT_ONLY_ACE
      - 0x00000008
    * - "IDENTIFIER_GROUP"
      - An ACE on which IDENTIFIER_GROUP is set indicates that the "who" refers to a group identifier.
      - CDMI_ACE_FLAGS_IDENTIFIER_GROUP
      - 0x00000040
    * - "INHERITED"
      - An ACE on which INHERITED is set indicates that this ACE is inherited from a parent directory. A server that supports automatic inheritance will place this flag on any ACEs inherited from the parent directory when creating a new object.
      - CDMI_ACE_FLAGS_INHERITED_ACE
      - 0x00000080

</DIV>
<DIV>

ACE Mask Bits
-----

The mask field of an ACE contains 32 bits. :rfc:`3530`.  


.. list-table:: <A NAME="50532475_18610"></A>ACE Bit Masks (Sheet 1 of 3)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - String Form
      - Description
      - Constant
      - Bit Mask
    * - "READ_OBJECT"
      - Permission to read the value of an object. 
If "READ_OBJECT" is not permitted: 


        * A CDMI GET that requests all fields shall return all fields with the exception of the value field. 
        * A CDMI GET that requests specific fields shall return the requested fields with the exception of the value field. 
        * A CDMI GET for only the value field shall return an HTTP status code of 403 Forbidden. 
        * A non-CDMI GET shall return an HTTP status code of 403 Forbidden.

      - CDMI_ACE_READ_OBJECT
      - 0x00000001
    * - "LIST_CONTAINER"
      - Permission to list the children of an object. 
If "LIST_CONTAINER" is not permitted: 


        * A CDMI GET that requests all fields shall return all fields with the exception of the children field and childrenrange field. 
        * A CDMI GET that requests specific fields shall return the requested fields with the exception of the children field and childrenrange field. 
        * A CDMI GET for only the children field and/or childrenrange field shall return an HTTP status code of 403 Forbidden.

      - CDMI_ACE_LIST_CONTAINER
      - 0x00000001
    * - "WRITE_OBJECT"
      - Permission to modify the value of an object 
If "WRITE_OBJECT" is not permitted, a PUT that requests modification of the value of an object shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_WRITE_OBJECT
      - 0x00000002
    * - "ADD_OBJECT"
      - Permission to add a new child data object or queue object. 
If "ADD_OBJECT" is not permitted, a PUT or POST that requests creation of a new child data object or new queue object shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_ADD_OBJECT
      - 0x00000002
    * - "APPEND_DATA"
      - Permission to append data to the value of a data object. 
If "APPEND_DATA" is permitted and "WRITE_OBJECT" is not permitted, a PUT that requests modification of any existing part of the value of an object shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_APPEND_DATA
      - 0x00000004
    * - "ADD_SUBCONTAINER"
      - Permission to create a child container object or domain object. 
If "ADD_SUBCONTAINER" is not permitted, a PUT that requests creation of a new child container object or new domain object shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_ADD_SUBCONTAINER
      - 0x00000004
    * - "READ_METADATA"
      - Permission to read the metadata of an object. 
If "READ_METADATA" is not permitted: 


        * A CDMI GET that requests all fields shall return all fields with the exception of the metadata field. 
        * A CDMI GET that requests specific fields shall return the requested fields with the exception of the metadata field. 
        * A CDMI GET for only the metadata field shall return an HTTP status code of 403 Forbidden.

      - CDMI_ACE_READ_METADATA
      - 0x00000008
    * - "WRITE_METADATA"
      - Permission to modify the metadata of an object.
If "WRITE_METADATA" is not permitted, a CDMI PUT that requests modification of the metadata field of an object shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_WRITE_METADATA
      - 0x00000010
    * - "EXECUTE"
      - Permission to execute an object.
      - CDMI_ACE_EXECUTE
      - 0x00000020
    * - "TRAVERSE_CONTAINER"
      - Permission to traverse a container object or domain object.
If "TRAVERSE_CONTAINER" is not permitted for a parent container, all operations against all children below that container shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_TRAVERSE_CONTAINER
      - 0x00000020
    * - "DELETE_OBJECT"
      - Permission to delete a child data object or child queue object from a container object. 
If "DELETE_OBJECT" is not permitted, all DELETE operations shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_DELETE_OBJECT
      - 0x00000040
    * - "DELETE_SUBCONTAINER"
      - Permission to delete a child container object from a container object or to delete a child domain object from a domain object. 
If "DELETE_SUBCONTAINER" is not permitted, all DELETE operations shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_DELETE_SUBCONTAINER
      - 0x00000040
    * - "READ_ATTRIBUTES"
      - Permission to read the attribute fields<EM CLASS="Superscript">
[1]</EM>
 of an object. 
If "READ_ATTRIBUTES" is not permitted: 


        * A CDMI GET that requests all fields shall return all non-attribute fields and shall not return any attribute fields. 
        * A CDMI GET that requests at least one non-attribute field shall only return the requested non-attribute fields. 
        * A CDMI GET that requests only non-attribute fields shall return an HTTP status code of 403 Forbidden. 

      - CDMI_ACE_READ_ATTRIBUTES
      - 0x00000080
    * - "WRITE_ATTRIBUTES"
      - Permission to change attribute fields<EM CLASS="Superscript">
[1]</EM>
 of an object. 
If "WRITE_ATTRIBUTES" is not permitted, a CDMI PUT that requests modification of any non-attribute field shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_WRITE_ATTRIBUTES
      - 0x00000100
    * - "WRITE_RETENTION"
      - Permission to change retention attributes of an object. 
If "WRITE_RETENTION" is not permitted, a CDMI PUT that requests modification of any non-hold retention metadata items shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_WRITE_RETENTION
      - 0x00000200
    * - "WRITE_RETENTION_HOLD"
      - Permission to change retention hold attributes of an object. 
If "WRITE_RETENTION_HOLD" is not permitted, a CDMI PUT that requests modification of any retention hold metadata items shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_WRITE_RETENTION_HOLD
      - 0x00000400
    * - "DELETE"
      - Permission to delete an object. 
If "DELETE" is not permitted, all DELETE operations shall return an HTTP status code of 403 Forbidden.
      - CDMI_ACE_DELETE
      - 0x00010000
    * - "READ_ACL"
      - Permission to read the ACL of an object. 
If "READ_ACL" is not permitted: 


        * A CDMI GET that requests all metadata items shall return all metadata items with the exception of the cdmi_acl metadata item. 
        * A CDMI GET that requests specific metadata items shall return the requested metadata items with the exception of the cdmi_acl metadata item. 
        * A CDMI GET for only the cdmi_acl metadata item shall return an HTTP status code of 403 Forbidden.

If "READ_ACL" is permitted and "READ_METADATA" is not permitted, then to read the ACL, a client CDMI GET for only the cdmi_acl metadata item shall be permitted.
      - CDMI_ACE_READ_ACL
      - 0x00020000
    * - "WRITE_ACL"
      - Permission to write the ACL of an object. 


        * If "WRITE_ACL" is not permitted, a CDMI PUT that requests modification of the cdmi_acl metadata item shall return an HTTP status code of 403 Forbidden. 
        * If "WRITE_ACL" is permitted and "WRITE_METADATA" is not permitted, then to write the ACL, a client CDMI PUT for only the cdmi_acl metadata item shall be permitted. 

      - CDMI_ACE_WRITE_ACL
      - 0x00040000
    * - "WRITE_OWNER"
      - Permission to change the owner of an object. 


        * If "WRITE_OWNER" is not permitted, a CDMI PUT that requests modification of the cdmi_owner metadata item shall return an HTTP status code of 403 Forbidden. 
        * If "WRITE_OWNER" is permitted and "WRITE_METADATA" is not permitted, then to write the owner, a client CDMI PUT for only the cdmi_owner metadata item shall be permitted. 

      - CDMI_ACE_WRITE_OWNER
      - 0x00080000
    * - "SYNCHRONIZE"
      - Permission to access an object locally at the server with synchronous reads and writes.
      - CDMI_ACE_SYNCHRONIZE
      - 0x00100000
    * <TH ROWSPAN="1" COLSPAN="4">
<EM CLASS="Superscript">
[1]</EM>
The value fields, children fields, and metadata field are considered to be non-attribute fields. All other fields are considered to be attribute fields. 


Implementations shall use the correct string form to display permissions, if the object type is known. If the object type is unknown, the "object" version of the string shall be used.
</DIV>
<DIV>

.. _50532475__Ref120237580:
ACL Evaluation
-----

When evaluating whether access to a particular object O by a principal P is to be granted, the server shall traverse the object's logical ACL (its ACL after processing inheritance from parent containers) in list order, using a temporary permissions bitmask m, initially empty (all zeroes).


* If the object still does not contain an ACL, the algorithm terminates and access is denied for all users and groups. This condition is not expected, as CDMI implementations should require an inheritable default ACL on all root containers.
* ACEs that do not refer to the principal P requesting the operation are ignored.
* If an ACE is encountered that denies access to P for any of the requested mask bits, access is denied and the algorithm terminates.
* If an ACE is encountered that allows access to P, the permissions mask m for the operation is XORed with the permissions mask from the ACE. If m is sufficient for the operation, access is granted and the algorithm terminates.
* If the end of the ACL list is reached and permission has neither been granted nor explicitly denied, access is denied and the algorithm terminates, unless the object is a container root. In this case, the server shall:
<LI CLASS="Bullet-Indent">
allow access to the container owner, ADMINISTRATOR@, and any member of ADMINUSERS@; and </LI>
<LI CLASS="Bullet-Indent">
log an event indicating what has happened.</LI>


When permission for the desired access is not explicitly given, even ADMINISTRATOR@ and equivalents are denied for objects that aren't container roots. When an admin needs to access an object in such an instance, the root container shall be accessed and its inheritable ACEs changed in a way as to allow access to the original object. The resulting log entry then provides an audit trail for the access.

When a root container is created and no ACL is supplied, the server shall place an ACL containing the following ACEs on the container:

    "cdmi_acl": 

    [

        {

            "acetype": "ALLOW",

            "identifier": "OWNER@",

            "aceflags": "OBJECT_INHERIT, CONTAINER_INHERIT",

            "acemask": "ALL_PERMS"

        },

        {

            "acetype": "ALLOW",

            "identifier": "AUTHENTICATED@",

            "aceflags": "OBJECT_INHERIT, CONTAINER_INHERIT",

            "acemask": "READ"

        }

    ]

As ACLs are storage system metadata, they are stored and retrieved through the metadata field included in a PUT or GET request. The syntax is as follows, using the constant strings from :ref:`ACE Types`, :ref:`ACE Flags`, and :ref:`ACE Bit Masks`, above. 

    ACL = { ACE [, ACE ...] }

    ACE = { acetype , identifier , aceflags , acemask }

    acetype = uint_t | acetypeitem

    identifier  = utf8string_t

    aceflags    = uint_t | aceflagsstring

    acemask     = uint_t | acemaskstring

    &nbsp;

    acetypeitem = aceallowedtype |

                  acedeniedtype |

                  aceaudittype

    aceallowedtype = "CDMI_ACE_ACCESS_ALLOWED_TYPE" | 0x0

    acedeniedtype  = "CDMI_ACE_ACCESS_DENIED_TYPE" | 0x01

    aceaudittype   = "CDMI_ACE_SYSTEM_AUDIT_TYPE" | 0x02

    &nbsp;

    aceflagsstring = aceflagsitem [| aceflagsitem ...]

    aceflagsitem   = aceobinherititem |

                     acecontinherititem |

                     acenopropagateitem | 

                     aceinheritonlyitem

    &nbsp;

    aceobinherititem   = "CDMI_ACE_OBJECT_INHERIT_ACE" | 0x01

    acecontinherititem = "CDMI_ACE_CONTAINER_INHERIT_ACE" | 0x02

    acenopropagateitem = "CDMI_ACE_NO_PROPAGATE_INHERIT_ACE" | 0x04

    aceinheritonlyitem = "CDMI_ACE_INHERIT_ONLY_ACE" | 0x08

    &nbsp;

    acemaskstring  =   acemaskitem [| acemaskitem ...]

    acemaskitem    =   acereaditem | acewriteitem | <BR>
    aceappenditem | acereadmetaitem |<BR>
    acewritemetaitem | acedeleteitem |<BR>
    acedelselfitem | acereadaclitem |<BR>
    acewriteaclitem | aceexecuteitem | <BR>
    acereadattritem | acewriteattritem | <BR>
    aceretentionitem

    acereaditem       = "CDMI_ACE_READ_OBJECT" |                       

                        "CDMI_ACE_LIST_CONTAINER" |      0x01                    

    acewriteitem      = "CDMI_ACE_WRITE_OBJECT" |                      

                       "CDMI_ACE_ADD_OBJECT" |         0x02                     

    aceappenditem     = "CDMI_ACE_APPEND_DATA" |                       

                        "CDMI_ACE_ADD_SUBCONTAINER" |  0x04                

    acereadmetaitem   = "CDMI_ACE_READ_METADATA" |   0x08

    acewritemetaitem  = "CDMI_ACE_WRITE_METADATA" | 0x10

    acedeleteitem     = "CDMI_ACE_DELETE_OBJECT" |                     

                        "CDMI_ACE_DELETE_SUBCONTAINER" | 0x40              

    acedelselfitem    = "CDMI_ACE_DELETE" |          0x10000                           

    acereadaclitem    = "CDMI_ACE_READ_ACL" |        0x20000 

    acewriteaclitem   = "CDMI_ACE_WRITE_ACL" |      0x40000                        

    aceexecuteitem    = "CDMI_ACE_EXECUTE" |  0x80000

    acereadattritem   = "CDMI_ACE_READ_ATTRIBUTES" | 0x00080

    acewriteattritem  = "CDMI_ACE_WRITE_ATTRIBUTES" | 0x00100

    aceretentionitem  = "CDMI_ACE_SET_RETENTION" | 0x10000000

When ACE masks are presented in numeric format, they shall, at all times, be specified in hexadecimal notation with a leading "0x". This format allows both servers and clients to quickly determine which of the two forms of a given constant is being used. When masks are presented in string format, they shall be converted to numeric format and then evaluated using standard bitwise operators.

When an object is created, no ACL is supplied, and an ACL is not inherited from the parent container (or there is no parent container), the server shall place an ACL containing the following ACEs on the object: 

    "cdmi_acl": 

    [

        {

            "acetype": "ALLOW",

            "identifier": "OWNER@",

            "aceflags": "OBJECT_INHERIT, CONTAINER_INHERIT",

            "acemask": "ALL_PERMS"

        }

    ]
</DIV>
<DIV>

Example ACE Mask Expressions
-----
<DIV>
#. &nbsp;

    .. code-block:: http


    "READ_ALL" | 0x02

   evaluates to 0x09 | 0x02 == 0x0
</DIV>
<DIV>
#. &nbsp;

    .. code-block:: http


    0x001F07FF

   evaluates to 0x001F07FF == "ALL_PERMS"
</DIV>
<DIV>
#. &nbsp;

    .. code-block:: http


    "RW_ALL" | DELETE

   evaluates to 0x000601DF | 0x00100000 == 0x000701DF
</DIV>
</DIV>
<DIV>

Canonical Format for ACE Hexadecimal Quantities
-----

ACE mask expressions may be evaluated and converted to a string hexadecimal value before transmission in a CDMI JSON body. Applications or utilities that display them to users should convert them into a text expression before display and accept user input in text format as well. 

The following technique should be used to decompose masks into strings... list-table of masks and string equivalents should be maintained and ordered from greatest to least:``    :header-rows: 1
    :widths: auto
    :align: center 


                 ``
<TABLE>
    * - ``0x001F07FF``

      - ``"ALL_PERMS"``

      - ``"ALL_PERMS"``

    * - ``0x0006006F``

      - ``"RW_ALL"``

      - ``"RW_ALL"``

    * - ``0x0000001F``

      - ``"RW"``

      - ``"RW"``

    * - ````
&nbsp;
      - ``...``

      - ````
&nbsp;
    * - ``0x00000002``

      - ``"WRITE_OBJECT"``

      - ``"ADD_OBJECT"``

    * - ``0x00000001``

      - ``"READ_OBJECT"``

      - ``"LIST_CONTAINER"``

</TABLE>

Given an access mask M, the following is repeated until M == 0:
<OL>
#. Select the highest mask m from t.. list-table such that M &amp; m == m.
    :header-rows: 1
    :widths: auto
    :align: center 


#. If the object is a container, select the string from the 3rd column; otherwise, select the string from the 2nd column.
#. Bitwise subtract m from M, i.e., set M = M xor m.
</OL>

The complete textual representation is then all the selected strings concatenated with ", " between them, e.g., "ALL_PERMS, WRITE_OWNER". The strings should appear in the order they are selected. 

A similar technique should be used for all other sets of hex/string equivalents. 

This algorithm, properly coded, requires only one (often partial) pass through the corresponding string equivalen.. list-table.
    :header-rows: 1
    :widths: auto
    :align: center 


</DIV>
<DIV>

JSON Format for ACLs
-----

ACE flags and masks are members of a 32-bit quantity that is widely understood in its hexadecimal representations. The JSON data format does not support hexadecimal integers, however. For this reason, all hexadecimal integers in CDMI ACLs shall be represented as quoted strings containing a leading "0x".

ACLs containing one or more ACEs shall be represented in JSON as follows:

    {

        "cdmi_acl" : [

            {

                "acetype" : "0xnn",

                "identifier" : "&lt;user-or-group-name&gt;",

                "aceflags" : "0xnn",

                "acemask" : "0xnn"

            },

            {

                "acetype" : "0xnn",

                "identifier" : "&lt;user-or-group-name&gt;",

                "aceflags" : "0xnn",

                "acemask" : "0xnn"

            } 

        ]

    }

ACEs in such an ACL shall be evaluated in order as they appear. 
<DIV>
<H6 CLASS="Example">
An example of an ACL embedded in a response to a GET request is as follows:</H6>

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

        "objectType" : "/application/cdmi-object",

        "objectID" : "00007ED9001086A99CC6487FEE373D82",

        "objectName" : "MyDataItem.txt",

        "parentURI" : "/MyContainer/",

        "domainURI" : "/cdmi_domains/MyDomain/",

        "capabilitiesURI" : "/cdmi_capabilities/dataobject/",

        "completionStatus" : "Complete",

        "mimetype" : "text/plain",

        "metadata" : {

            "cdmi_size" : "17",

            "cdmi_acl" : [

                {

                    "acetype" : "0x00",

                    "identifier" : "EVERYONE@",

                    "aceflags" : "0x00",

                    "acemask" : "0x00020089"

                } 

            ],

            ... 

        },

        "valuerange" : "0-16",

        "value" : "Hello CDMI World!" 

    }
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532475__Ref126790916:
.. _50532475__Ref126790869:
<A NAME="50532475__Ref120976323"></A><A NAME="50532475__Ref120976253"></A>Support for User Metadata
************************

All CDMI objects that support metadata shall permit the inclusion of arbitrary user-defined metadata items, with the restriction that the name of a user-defined metadata item shall not start with the prefix "cdmi_".


* The maximum number of user-defined metadata items is specified by the capability cdmi_metadata_maxitems.
* The maximum size of each user-defined metadata item is specified by the capability cdmi_metadata_maxsize.
* The maximum total size of user-defined metadata items for an object is specified by the capability cdmi_metadata_maxtotalsize.

</DIV>
<DIV>
.. _50532475__Ref127335727:
.. _50532475__Ref127335691:
<A NAME="50532475__Ref120976450"></A><A NAME="50532475__Ref120976421"></A>Support for Storage System Metadata
************************

After an object has been created, the storage system metadata, as described in :ref:`Storage System Metadata`, shall be generated by the cloud storage system and shall immediately be made available to a CDMI client in the metadata that is returned as a result of the create operation and any subsequent retrievals.


.. list-table:: <A NAME="50532475_57799"></A>Storage System Metadata (Sheet 1 of 3)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_size
      - JSON String
      - The number of bytes consumed by the object. This storage system metadata item is computed by the storage system, and any attempts to set or modify it will be ignored.
      - Optional
    * - cdmi_ctime
      - JSON String
      - The time when the object was created, in  ISO-8601
 point-in-time format, as described in :ref:`Time Representations`.
This metadata value can only be updated by a client if it has the "backup_operator" privilege. If a client does not have the "backup operator privilege, updates of this metadata item shall be ignored.
      - Optional
    * - cdmi_atime
      - JSON String
      - The time when the object was last accessed in ISO-8601 point-in-time format, as described in :ref:`Time Representations`. The access or modification of a child is not considered an access of a parent container (access/modify times do not propagate up the tree). For a newly created object, this value shall be set to the creation time.
This metadata value can only be updated by a client if it has the "backup_operator" privilege. If a client does not have the "backup operator privilege, updates of this metadata item shall be ignored.
      - Optional
    * - cdmi_mtime
      - JSON String
      - The time when the object was last modified, in ISO-8601 point-in-time format, as described in :ref:`Time Representations`. The modification of a child is not considered a modification of a container object (modification times do not propagate up the tree). For a newly created object, this value shall be set to the creation time.
This metadata value can only be updated by a client if it has the "backup_operator" privilege. If a client does not have the "backup operator privilege, updates of this metadata item shall be ignored.
      - Optional
    * - cdmi_acount
      - JSON String
      - The number of times that the object has been accessed since it was originally created. Accesses include all reads, writes, and lists. For a newly created object, this value shall be set to the value "0".
This metadata value can only be updated by a client if it has the "backup_operator" privilege. If a client does not have the "backup operator privilege, updates of this metadata item shall be ignored.
      - Optional
    * - cdmi_mcount
      - JSON String
      - The number of times that the object has been modified since it was originally created. Modifications include all value and metadata changes. Modifications to metadata resulting from reads (such as updates to atime) do not count as a modification. For a newly created object, this value shall be set to the value "0".
This metadata value can only be updated by a client if it has the "backup_operator" privilege. If a client does not have the "backup operator privilege, updates of this metadata item shall be ignored.
      - Optional
    * - cdmi_hash
      - JSON String
      - The hash of the value of the object, encoded using Base16 encoding rules described in :rfc:`4648`. This metadata field shall be present when the cdmi_value_hash data system metadata for the object or a parent object indicates that the value of the object should be hashed.
      - Optional
    * - cdmi_owner
      - JSON String
      - The name of the principal that has owner privileges for the object.
      - Mandatory
    * - cdmi_acl
      - JSON Array of JSON Objects
      - Standard ACL metadata. If not specified when the object is created, this metadata shall be filled in by the system.
      - Optional

</DIV>
<DIV>
.. _50532475__Ref127340730:
.. _50532475__Ref121028185:
<A NAME="50532475__Ref121028139"></A><A NAME="50532475__Ref120976603"></A>Support for Data System Metadata
************************

When specified, data system metadata provides guidelines to the cloud storage system on how to provide storage data services for data managed through the CDMI interface.

Data system metadata (see :ref:`Data System Metadata`) is inherited from parent objects to any children. If a child explicitly contains data system metadata, the metadata value of the child data system metadata shall override the metadata value of the parent data system metadata. 


.. list-table:: <A NAME="50532475_81867"></A>Data System Metadata (Sheet 1 of 6)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_data_redundancy
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a desired number of complete copies. Additional copies may be made to satisfy demand for the value. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used.
      - Optional
    * - cdmi_immediate_redundancy
      - JSON String
      - If this data system metadata item is present and set to "true", it indicates that the client is requesting that at least the number of copies indicated in cdmi_data_redundancy  contain the newly written value before the operation completes. This metadata is used to make sure that multiple copies of the data are written to permanent storage to prevent possible data loss. When this data system metadata item is absent, or is present and is not set to "true", this data system metadata item shall not be used. 
If the requested number of copies cannot be created within the HTTP timeout period, the transaction shall complete, but the cdmi_immediate_redundancy_provided data system metadata shall be set to "false".  
      - Optional
    * - cdmi_assignedsize
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is specifying the size in bytes that is desired to be reported for a container object exported via other protocols (see :ref:`Container Metadata`
). The system is not required to reserve this space and may thin-provision the requested space. Thus, the requested value may be greater than the actual storage space consumed. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used. 
This data system metadata item is only applied against container objects and is not inherited by child objects.
      - Optional
    * - cdmi_infrastructure_redundancy
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a desired number of independent storage infrastructures supporting the multiple copies of data. This metadata is used to convey that, of the copies specified in cdmi_data_redundancy, these copies shall be stored on this many separate infrastructures. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used. 
      - Optional
    * - cdmi_data_dispersion
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a minimum desired distance (in km) between the infrastructures supporting the multiple copies of data. This metadata is used to separate the (cdmi_infrastructure_redundancy number of) infrastructures by a minimum geographic distance to prevent data loss due to site disasters. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used.
      - Optional
    * <TD ROWSPAN="2" COLSPAN="1">
cdmi_geographic_placement
<TD ROWSPAN="2" COLSPAN="1">
JSON Array of JSON Strings
<TD ROWSPAN="2" COLSPAN="1">
If this data system metadata item is present and set to zero or more geopolitical identifiers, it indicates that the client is requesting restrictions on the geographic regions where the object is permitted to be stored. Each geopolitical identifier shall be in the form of either a string containing a valid ISO 3166 country/country-subdivision code, which indicates that storage is permitted within that geopolitical region, or in the form of a string starting with the "!" character in front of a valid ISO 3166 country/country-subdivision code, which excludes that country/country-subdivision from the previous list of geopolitical regions. 
The list is evaluated, in order, from left to right, with evaluation of each candidate storage location stopping when the candidate location is a permitted or prohibited region or is contained within a permitted or prohibited region. In addition to the ISO 3166 codes, "*" shall indicate all regions. If a candidate location does not match any of the entries in the list, the candidate location shall be considered to be prohibited. 


        * When this data system metadata item is absent, this data system metadata item shall not be used. 
        * When this data system metadata item is present and does not contain valid geopolitical identifiers, the create, update, or deserialize operation shall fail with an HTTP status code of ``400 Bad Request.``
 
        * When this data system metadata item is present and valid, but no available storage locations are permitted, the create, update, or deserialize operation shall fail with an HTTP status code of ``403 Forbidden.``


<TD ROWSPAN="2" COLSPAN="1">
Optional
    *     * - cdmi_retention_id
      - JSON String
      - If this data system metadata item is present and not an empty string, it indicates that the client is requesting that the string be used to tag a given object as being managed by a specific retention policy. This data system metadata item is not required to place an object under retention, but is useful when needing to be able to perform a query to find all objects under a specific retention policy. When this data system metadata item is absent, or is present and an empty string, this data system metadata item shall not be used.
      - Optional
    * - cdmi_retention_period
      - JSON String
      - If this data system metadata item is present and contains a valid ISO 8601:2004 time interval (as described in <A HREF="../../CDMI 1.0.2/FM 1.0.2/5-Overview_of_Cloud_Storage.htm#47707" CLASS="XRef"></A>
), it indicates that the client is requesting that an object be placed under retention (see :ref:`CDMI Retention`)
. When this data system metadata item is absent, this data system metadata item shall not be used. When this data system metadata item is present but does not contain a valid ISO 8601:2004 time interval, the create, update, or deserialize operation shall fail with an HTTP status code of ``400 Bad Request``
.
If this data system metadata item is updated and the new end date is before the current end date, the update operation shall fail with an HTTP status code of ``403 Forbidden``
. 
      - Optional
    * - .. _50532475_90990:
cdmi_retention_autodelete
      - JSON String
      - If this data system metadata item is present and set to "true", it indicates that the client is requesting that an object under retention be automatically deleted when retention expires. When this data system metadata item is absent, or is present and is not set to "true", this data system metadata item shall not be used.
      - Optional
    * - cdmi_hold_id
      - JSON Array of JSON Strings
      - If this data system metadata item is present and not an empty array, it indicates that the client is requesting that an object be placed under hold (see :ref:`CDMI Hold`
). Each string in the array shall contain a unique user-specified hold identifier. 
When this data system metadata item is absent, or is present and is an empty JSON array, this data system metadata item shall not be used. 
If this data system metadata item is updated, and a previously existing hold string has been removed or changed in the update, the update operation shall fail with an HTTP status code of ``403 Forbidden``
. (See :ref:`CDMI Hold`
 concerning releasing holds.)
      - Optional
    * <TD ROWSPAN="3" COLSPAN="1">
.. _50532475_71042:
cdmi_encryption
<TD ROWSPAN="3" COLSPAN="1">
JSON String
<TD ROWSPAN="3" COLSPAN="1">
If this data system metadata item is present and not an empty string, it indicates that the client is requesting that the object be encrypted while at rest. If encrypted, all data and metadata related to the object shall be encrypted. Supported algorithm/mode/length values are provided by the cdmi_encryption capability. 
When this data system metadata item is absent, this data system metadata item shall not be used. 
If this data system metadata item is present but does not contain a valid encryption algorithm/mode/length string, the system is free to choose to ignore the data system metadata, to fail with an HTTP status code of ``400 Bad Request``, or to select an encryption algorithm/mode/length of the system's choice. 
Supported encryption algorithms are expressed as a string in the form of ALGORITHM_MODE_KEYLENGTH, where: 


        * "ALGORITHM" is the encryption algorithm (e.g., "AES" or "3DES"). 
        * "MODE" is the mode of operation (e.g., "XTS", "CBC", or "CTR"). 
        * "KEYLENGTH" is the key size in bytes (e.g., "128", "192", "256"). 

To improve interoperability between CDMI implementations, the following designators should be used for the more common encryption combinations: 


        * "3DES_ECB_168" for the three-key TripleDES algorithm, the Electronic Code Book (ECB) mode of operation, and a key size of 168 bits; 
        * "3DES_CBC_168" for the three-key TripleDES algorithm, the Cipher Block Chaining (CBC) mode of operation, and a key size of 168 bits; 
        * "AES_CBC_128" for the AES algorithm, the CBC mode of operation, and a key size of 128 bits; 
        * "AES_CBC_256" for the AES algorithm, the CBC mode of operation, and a key size of 256 bits; 
        * "AES_XTS_128" for the AES algorithm, the XTS mode of operation, and a key size of 128 bits; and 
        * "AES_XTS_256" for the AES algorithm, the XTS mode of operation, and a key size of 256 bits.

<TD ROWSPAN="3" COLSPAN="1">
Optional
    *     *     * - .. _50532475_67296:
cdmi_value_hash 
      - JSON String
      - If this data system metadata item is present and not an empty string, it indicates that the client is requesting that the system hash the object value using the hashing algorithm and length requested. The result of the hash shall be provided in the cdmi_hash storage system metadata item. Supported algorithm/length values are provided by the cdmi_value_hash capability. 
When this data system metadata item is absent, this data system metadata item shall not be used. 
If this data system metadata item is present but does not contain a valid hash algorithm/length string, the system is free to choose to ignore the data system metadata, to fail with an HTTP status code of ``400 Bad Request``, or to select a hash algorithm/length of the system's choice. 
Supported hash algorithms are expressed as a string in the form of ALGORITHM LENGTH, where: 


        * "ALGORITHM" is the hash algorithm (e.g., "SHA"). 
        * "LENGTH" is the hash size in bytes (e.g., "160", "256"). 

To improve interoperability between CDMI implementations, the following designators should be used for the more common encryption combinations: 


        * "SHA160" for SHA-1, and 
        * "SHA256" for SHA-2.

      - Optional
    * - cdmi_latency
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a desired maximum time to first byte, in milliseconds. This metadata is the desired latency (in milliseconds) to the first byte of data, as measured from the edge of the cloud and factoring out any propagation latency between the client and the cloud. For example, this metadata may be used to determine, in an interoperable way, from what type of storage medium the data may be served. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used.
      - Optional
    * - cdmi_throughput
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a desired maximum data rate on retrieve, in bytes per second. This metadata is the desired bandwidth to the data, as measured from the edge of the cloud and factoring out any bandwidth capability between the client and the cloud. This metadata is used to stage the data in locations where there is sufficient bandwidth to accommodate a maximum usage. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used. 
      - Optional
    * - .. _50532475_61667:
cdmi_sanitization_method
      - JSON String
      - If this data system metadata item is present and not an empty string, it indicates that the client is requesting that the system use a specific sanitization method to delete data such that the data is unrecoverable after an update or delete operation. Supported sanitization method values are provided by the cdmi_sanitization_method capability. 
When this data system metadata item is absent, this data system metadata item shall not be used. 
If this data system metadata item is present but does not contain a valid sanitization method string, the system is free to choose to ignore the data system metadata, to fail with an HTTP status code of ``400 Bad Request``, or to select a sanitization method of the system's choice.
Supported sanitization methods are defined as system-specific strings.
      - Optional
    * - cdmi_RPO
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting a largest acceptable duration in time between an update or create and when the object may be recovered, specified in seconds. This metadata is used to indicate the desired backup frequency from the primary copy or copies of the data to the secondary copy or copies. It is the maximum acceptable time period before a failure or disaster during which changes to data may be lost as a consequence of recovery. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used. 
      - Optional
    * - cdmi_RTO
      - JSON String
      - If this data system metadata item is present and set to a positive numeric string, it indicates that the client is requesting the largest acceptable duration in time to restore data, specified in seconds. This metadata is used to indicate the desired maximum acceptable duration to restore the primary copy or copies of the data from a secondary backup copy or copies. When this data system metadata item is absent, or is present and is not set to a positive numeric string, this data system metadata item shall not be used.
      - Optional
    * - .. _50532475_87107:
cdmi_authentication_methods
      - JSON Array of JSON Strings
      - The client shall set this metadata to a list of authentication methods requested to be enabled for the domain.
Supported authentication method values are indicated by the cdmi_authentication_methods capability.
      - &nbsp;

</DIV>
<DIV>

Support for Provided Data System Metadata
************************

For each metadata item in a data system, there is an actual value that the cloud service is able to achieve at this time, as shown in :ref:`Provided Values of Data Systems Metadata Items`. Data system-provided metadata items are read only. Updates of these metadata items shall be ignored.


.. list-table:: <A NAME="50532475_18114"></A>Provided Values of Data Systems Metadata Items (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_data_redundancy_provided
      - JSON String
      - Contains the current number of complete copies of the data object at this time
      - Optional
    * - cdmi_immediate_redundancy_provided
      - JSON String
      - If present and set to "true", indicates if immediate redundancy is provided for the object
      - Optional
    * - cdmi_infrastructure_redundancy_provided
      - JSON String
      - Contains the current number of independent storage infrastructures supporting the data currently operating
      - Optional
    * - cdmi_data_dispersion_provided
      - JSON String
      - Contains the current lowest distance (km) between any two infrastructures hosting the data
      - Optional
    * - cdmi_geographic_placement_provided
      - JSON Array of JSON Strings
      - Contains an ISO-3166 identifier that corresponds to a geopolitical region where the object is stored
      - Optional
    * - cdmi_retention_period_provided
      - JSON String
      - Contains an :ref:`ISO 8601:2004` time interval (as described in :ref:`Time Representations`) specifying the period the object is protected by retention
      - Optional
    * - cdmi_retention_autodelete_provided
      - JSON String
      - Contains "true" if the object will automatically be deleted when retention expires
      - Optional
    * - cdmi_hold_id_provided
      - JSON Array of JSON Strings
      - Contains the user-specified hold identifiers for active holds
      - Optional
    * - cdmi_encryption_provided
      - JSON String
      - Contains the algorithm used for encryption, the mode of operation, and the key size. (See :ref:`cdmi_encryption` in :ref:`Data System Metadata` for the format.)
      - Optional
    * - cdmi_value_hash_provided
      - JSON String
      - Contains the algorithm and length being used to hash the object value. (See :ref:`cdmi_value_hash` in :ref:`Data System Metadata` for the format.)
      - Optional
    * - cdmi_latency_provided
      - JSON String
      - Contains the provided maximum time to first byte
      - Optional
    * - cdmi_throughput_provided 
      - JSON String
      - Contains the provided maximum data rate on retrieve
      - Optional
    * - cdmi_sanitization_method_provided
      - JSON String
      - Contains the sanitization method used. (See :ref:`cdmi_sanitization_method` in :ref:`Data System Metadata` for the format.)
      - Optional
    * - cdmi_RPO_provided
      - JSON String
      - Contains the provided duration, in seconds, between an update and when the update may be recovered
      - Optional
    * - cdmi_RTO_provided
      - JSON String
      - Contains the provided duration, in seconds, to restore data
      - Optional
    * - cdmi_authentication_methods_provided
      - JSON Array of JSON Strings
      - Contains a list of authentication methods enabled for the domain. (See :ref:`cdmi_authentication_methods` in :ref:`Data System Metadata` for the format.)
      - Optional

</DIV>
<DIV>

Metadata Update Operations
************************

CDMI permits a client to replace all metadata items or to perform operations against one or more individual metadata items. 

Replacing all metadata items is accomplished by including the metadata field in the update request body JSON and not specifying specific metadata items in the update URI. 

Adding, updating, and removing specific metadata items is accomplished by specifying the specific metadata item names in the update URI: 


* To add a new metadata item to an existing object, the metadata item name shall be included in the update request URI, and the metadata item shall be included in the metadata field in the update request body JSON. 
* To update the value of an existing metadata item, the metadata item name shall be included in the update request URI, and the metadata item shall be included in the metadata field in the update request body JSON. 
* To remove an existing metadata item, the metadata item name shall be included in the update request URI, and the metadata item shall not be included in the metadata field in the update request body JSON. 


When individual metadata items are specified in the update URI, metadata items included in the metadata field in the request body JSON that are not referred to in the update URI shall be ignored.

&nbsp;
</DIV>
</DIV>
<DIV>
.. _50532476__Toc127343546:
.. _50532476__Ref126820889:
<A NAME="50532476__Ref121058882"></A>Retention and Hold Management
========================================
<DIV>

Introduction
************************

A cloud storage system may optionally implement retention management disciplines into the system management functionality of the cloud-based storage system. The implementation of retention and hold capabilities is indicated by the presence of the cloud storage system-wide capabilities for retention and hold capabilities.

Retention management includes implementing a retention policy, defining a hold policy to enable objects to be held for specific purposes (e.g., litigation), and defining how the rules for deleting objects are affected by placing either a retention policy and/or a hold on an object. CDMI™ object deletion is not a capability of retention management, per se, but rather is a general system capability. However, this clause describes what happens when placing either a retention policy and/or a hold on an object.

Retention management may be applied to the following object types:


* data objects,
* queue objects, and
* container objects.

</DIV>
<DIV>

Retention Management Disciplines
************************

CDMI retention, deletion, and hold management affect any CDMI client that creates or deletes CDMI objects, as these disciplines mandate how a cloud storage system manages CDMI objects when they are created and until they are deleted. 

CDMI retention management is comprised of three management disciplines: retention, hold, and deletion: 


* CDMI retention uses retention time criteria to determine the time period during which object deletion from the CDMI-based system is prohibited. No changes to the object are allowed, even after the retention period has expired, except as specified below. 
* CDMI hold prohibits object deletion and modification until all holds on the object have been released. 
* A CDMI-based system shall not allow the deletion of a CDMI object before the CDMI retention time criteria are met or while holds exist. Any deletion attempts (e.g., by a CDMI application) shall return an error. 
* After the CDMI retention time criteria have been met and all holds have been released, CDMI retention and holds shall no longer be a reason to prohibit object deletion. 
* Once the retention period has started or if holds exist, changes to the object data and metadata shall not be allowed, with the exception of extensions to the retention and hold data system metadata. The retention data system metadata may be added or the retention period extended, and the hold data system metadata may be added or extended with additional holds. Any other attempt to modify the object shall return an error.

</DIV>
<DIV>

CDMI Retention
************************
<DIV>

Overview
-----

CDMI retention only allows one retention policy to be applied to an object at a time. 

Retention management uses time criteria to determine the time period during which CDMI object deletion from the CDMI-based system shall be prohibited. CDMI retention criteria shall be specified by the following data system metadata:


* a retention criteria identifier—a CDMI client-specified string that shall identify the retention records class (cdmi_retention_id); and
* a retention start time and retention period time—the start time, when used together with period, indicating when retention shall no longer be enforced (cdmi_retention_period).


When a CDMI client attempts to delete an object, the cloud storage system shall evaluate all such retention criteria and return an error, if any retention criteria have not been met.

When copying objects with a retention policy, retention properties shall not be transferred from the source CDMI object to the destination object, and the destination object shall not have a retention policy.

:ref:`Object Retention` shows how to establish time-based retention with a retention identifier. The value of the object data system metadata for the retention period shall not be reduced.


<H6 CLASS="Figure-Caption">
.. _50532476_45053:
Object Retention</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-9.gif" ALT="">
</DIV>
</TABLE>

A specific HTTP error code (403) shall be returned on operations to objects that are under retention period when the cloud storage system attempts to change or delete the object before the retention period criteria are met. 

A cloud storage system shall not prevent metadata changes that increase the retention period, as there are valid business reasons to change a retention period for an object.
</DIV>
<DIV>

Examples
-----
<DIV>
#. Place an existing object under retention:

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_retention_id;metadata:cdmi_retention_period HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"metadata" : {

    		"cdmi_retention_id" : "1",

    		"cdmi_retention_period" : "2010-04-28T00:00:00.000000Z/2012-04-27T00:00:00.000000Z"

    	}

    }

   The following shows the response.

    HTTP/1.1 204 No Content
</DIV>
<DIV>
#. Increase the duration of retention on an existing object under retention:

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_retention_period HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"metadata" : {

    		"cdmi_retention_period" : "2011-04-28T00:00:00.000000Z/2013-04-27T00:00:00.000000Z"

    	}

    }

   The following shows the response.

    HTTP/1.1 204 No Content
</DIV>
<DIV>
#. Decrease the duration of retention on an existing object under retention:

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_retention_period HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"metadata" : {

    		"cdmi_retention_period" : "2011-04-28T00:00:00.000000Z/2012-01-27T00:00:00.000000Z"

    	}

    }

   The following shows the response.

    HTTP/1.1 403 Forbidden
</DIV>
</DIV>
</DIV>
<DIV>

CDMI Hold
************************
<DIV>

Overview
-----

CDMI hold enforces read-only data object access and prohibition of object deletion. A cloud storage system shall allow multiple holds to be applied to a single object to satisfy multiple hold orders. While an object is on hold, a cloud storage system shall strictly enforce read-only access to the object and prohibit object deletion.

When copying objects that are on hold, hold properties shall not be transferred from the source CDMI object to the destination object, and the destination object shall not be on hold.

Hold management uses a hold indicator to determine the time period(s) during which CDMI object revision (data and metadata) and deletion from the CDMI-based system shall be prohibited. CDMI hold criteria shall be specified by data system metadata, specifically, a hold criteria identifier that is a client-specified string that shall identify the holds and their order.

A CDMI client may place an object on hold by adding a hold identifier to the cdmi_hold_id data system metadata item. When an object is on hold, CDMI clients shall be subject to failures or unexpected state changes on operations, which would otherwise be successful if the object was not on hold.

:ref:`Object Hold` shows how placing a hold on an object affects its read-only and deletion capability.


<H6 CLASS="Figure-Caption">
.. _50532476_63395:
Object Hold</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-10.gif" ALT="">
</DIV>
</TABLE>

:ref:`Object Hold on Object with Retention` shows how to establish time-based retention with a retention identifier that has a hold placed on the object. The value of the object data system metadata for the retention period shall not be reduced, and the value of the object data system metadata for hold identifiers shall not permit holds to be removed. Removing holds is outside the scope of the CDMI international standard.


<H6 CLASS="Figure-Caption">
.. _50532476_61581:
Object Hold on Object with Retention</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-11.gif" ALT="">
</DIV>
</TABLE>

:ref:`Object with Multiple Holds` shows how placing multiple holds on an object affects its read-only and deletion capability.


<H6 CLASS="Figure-Caption">
.. _50532476_88327:
Object with Multiple Holds</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-12.gif" ALT="">
</DIV>
</TABLE>

A cloud storage system shall maintain an on-hold object in read-only mode with respect to the application access to data and metadata and shall prohibit deletion, either automated or explicit. 


* CDMI clients shall tolerate these object on-hold failures or state changes.
* Releases from hold are not part of this international standard and are typically performed out of band using an additionally secured non-CDMI mechanism provided by the implementation.


A specific HTTP error code (403) shall be returned on operations to objects that are under a hold when the system attempts to change the object or attempts to delete the object before the hold is removed. This failure should be a an error to the application.
</DIV>
<DIV>

Examples
-----
<DIV>
#. Place an existing object under hold: 

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_hold_id HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

      "metadata": {

        "cdmi_hold_id": {

           "case_7": ""

        }

      }

    }

   The following shows the response.

    HTTP/1.1 204 No Content
</DIV>
<DIV>
#. Attempt to remove a hold for an object under hold: 

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_hold_id HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

      "metadata": {

        "cdmi_hold_id": {}

      }

    }

   The following shows the response.

    HTTP/1.1 403 Forbidden
</DIV>
<DIV>
#. Add a second hold to an object under hold:

    .. code-block:: http


    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_hold_id HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

      "metadata":{

        "cdmi_hold_id": {

           "case_7": "",

           "case_15": ""

       }

     	}

    }

   The following shows the response.

    HTTP/1.1 204 No Content
</DIV>
</DIV>
</DIV>
<DIV>

CDMI Auto-deletion
************************
<DIV>

Overview
-----

CDMI deletion controls cloud storage system actions with respect to object deletion. A cloud storage system may automatically delete a CDMI object after the retention time and hold criteria have been met. (See :ref:`cdmi_retention_autodelete` in :ref:`Data System Metadata`.)

CDMI objects shall be automatically deleted by the system at the retention period expiration by setting the data system metadata flag cdmi_retention_autodelete. The cdmi_retention_autodelete flag indicates to the system that the object shall be made unavailable for access after the retention criteria have been satisfied. The system shall ensure that the object is no longer available through the CDMI interface. If the system has satisfied the retention requirement and a hold is established for the object, the object shall not be made unavailable or deleted. When a hold and retention have been applied to an object, both need to be satisfied (retention period expired and no holds existing) for objects to be automatically deleted from the system. 
<DIV>
<H6 CLASS="Example">
Place an object under retention with autodelete:</H6>

    PUT /MyContainer/MyDataObject.txt?metadata:cdmi_retention_period;metadata:cdmi_retention_autodelete HTTP/1.1

    Host: cloud.example.com

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"metadata":{

    		"cdmi_retention_period": "2011-04-28T00:00:00.000000Z/2013-04-27T00:00:00.000000Z",

    		"cdmi_retention_autodelete": "true"

    	}

    }

   The following shows the response.

    HTTP/1.1 204 No Content
</DIV>
</DIV>
</DIV>
<DIV>

Retention Security Considerations
************************

The accuracy and integrity of the retention start and elapsed times depend on the accuracy and integrity of the clock that is used to set their values. Equally important is the relative accuracy and security of the clock that determines if the retention period has elapsed when compared to the clock that sets the start time property. Relative time differences between these two clocks may lead to undesirable retention and deletion management behavior.

It is important to have a reliable source from which the system clock is set. A stratum 1 time is directly connected to a reference clock and is at the top of the time server hierarchy. Relative time differences between the system clock and the reference clock may lead to undesirable retention timestamps and difficulties with time action events. 
<DIV>
<H6 CLASS="Example">
An object is created in a cloud storage system at time 0 with a period of 8 years and autodelete of TRUE. At time 1 year, the system clock is adjusted forward to 9 years. Now, because the system time is 9 years, the retention time criterion is satisfied, even though only 1 year has actually elapsed. And, since autodelete is TRUE, the system automatically deletes the object.</H6>

The specification for accuracy and integrity of timekeeping is not within the scope of CDMI. However, to prevent undesirable retention and deletion management consequences, systems should maintain accurate clock time, with zero or minimal deviation to clock integrity.
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532477_33287:
Scope Specification
========================================
<DIV>

Introduction
************************

CDMI™ provides a standardized mechanism to define sets of objects that match certain characteristics. This mechanism is known as a CDMI scope specification. Scope specifications are typically used to provide a CDMI client with a way to indicate in what set of CDMI objects it is interested.

Each JSON object within the scope specification represents a set of conditions that shall all be true in order for an object to be considered to match against the scope (a logical AND relationship). For queries, a matching object would be returned in the query results. An empty scope specification is considered to evaluate to true. Multiple JSON objects are used to express logical OR relationships, where if any JSON object in the scope evaluates to true, then the object shall be considered to have matched against the scope.

Each JSON object is constructed using the same structure that CDMI objects use. To show this structure, assume the following result from a CDMI GET for a data object:

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007E7F0010EB9092B29F6CD6AD6824",

    	"objectName" : "MyDataObject.txt",

    	"parentURI" : "/MyContainer/",

         "parentID" : "00007E7F00102E230ED82694DAA975D2", 

    	"domainURI" : "/cdmi_domains/MyDomain/",

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/",

    	"completionStatus" : "Complete",

    	"mimetype" : "text/plain",

    	"metadata" : {

    		"cdmi_size" : "108263",

    		...

    	},

    	"valuerange" : "0-108262",

    	"value" : "..."

    }
</DIV>
<DIV>

Examples
************************

Each field inside a scope specification JSON object represents a condition that shall be met for a field. 
<DIV>
#. A query to find all objects belonging to the domain /cdmi_domains/MyDomain/ is structured as follows: 

    .. code-block:: http


    [

        {

            "domainURI" : "== /cdmi_domains/MyDomain/"

        }

    ]
</DIV>
<DIV>
#. To query for all objects belonging to the domain /cdmi_domains/MyDomain/ AND are also located within the container MyContainer, the scope specification is structured as follows: 

    .. code-block:: http


    [

        {

            "parentURI" : "== /MyContainer/",

            "domainURI" : "== /cdmi_domains/MyDomain/"

        }

    ]
</DIV>
<DIV>
#. To query for all objects created within a certain time range, the scope specification is structured as follows:

    .. code-block:: http


    &nbsp;

        {

            "metadata": {

                "cdmi_ctime": [

                    "&gt;=2012-01-01T00:00:00",

                    "&lt;=2013-01-01T00:00:00"

                ]

            }

        }

    ]

When multiple matching expressions are specified for a given field or metadata item, all matching expression must evaluate true for an object to be considered a query result.
</DIV>
<DIV>
#. To query for all objects that belong to the domain MyDomain OR are located within the container MyContainer, the query is structured as follows: 

    .. code-block:: http


    [

        {

            "parentURI" : "== /MyContainer/",

        },

        {

            "domainURI" : "== /cdmi_domains/MyDomain/"

        }

    ]

Queries may match on any field within an object that a cloud storage system is capable of returning as a result of an object GET.
</DIV>
<DIV>
#. To query metadata items, the metadata object is included as an object within the query request. This query is shown as follows:

    .. code-block:: http


    [

        {

            "metadata" : {

                "colour" : "== blue"

            }

        }

    ]

This approach allows matching against arbitrarily nested metadata structures. When a JSON object is included in the scope specification, matches are performed within that object, and when a JSON array is included in the scope specification, matches are performed within that array. Matching against the contents of arrays of objects is indicated by having an object within the array, as illustrated in Example 5. 
</DIV>
<DIV>
#. To query all objects with an ACE associated with the user "jdoe": 

    .. code-block:: http

<P CLASS="CODE-continuous-indent">
[</P>
<P CLASS="CODE-continuous-indent">
    {</P>
<P CLASS="CODE-continuous-indent">
        "metadata" : {</P>
<P CLASS="CODE-continuous-indent">
            "cdmi_acl" : [</P>
<P CLASS="CODE-continuous-indent">
                {</P>
<P CLASS="CODE-continuous-indent">
                    "identifier" : "== jdoe"</P>
<P CLASS="CODE-continuous-indent">
                }</P>
<P CLASS="CODE-continuous-indent">
            ]</P>
<P CLASS="CODE-continuous-indent">
        }</P>
<P CLASS="CODE-continuous-indent">
    }</P>
<P CLASS="CODE-continuous-indent">
]</P>

To query the value of objects, the value field is included within the query request. Values are always represented using base 64 encoding in queries. 
</DIV>
<DIV>
#. This query is shown as follows:

    .. code-block:: http


    {

       [

           {

               "value": "== Ymx1ZQ=="

           }

       ]

    }

Query against the value of objects is optional and is indicated by the presence of the cdmi_query_value capability.
</DIV>
</DIV>
<DIV>

Query Matching Expressions
************************

:ref:`Query Matching Expressions` defines the query matching expressions.


.. list-table:: <A NAME="50532477_81512"></A>Query Matching Expressions (Sheet 1 of 4)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Matching Expression
      - Description
    * - "field" : "*"
      - The exists matching expression tests for the existence of the field. If the field is present, even if empty, the condition shall be considered to be met.
    * - "field" : "!*"
      - The not exists matching expression tests for the non-existence of the field. If the field is absent, the condition shall be considered to be met.
    * - "field" : "== constant"
      - The equals matching expression tests for the equality of the value of the field and a specified constant value. The equality test is case sensitive. 
The leading space after the "==" and before the constant value is not included in the comparison. If the constant value matches the value of the field, the condition shall be considered to be met.
    * - "field" : "#== constant"
      - The numeric equals matching expression tests for the numeric equality of the value of the field and a specified constant value.
Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "!= constant"
      - The not equals matching expression tests for the non-equality of the value of the field and a specified constant value. The not-equals test is case sensitive. 
The leading space character after the "!=" and before the constant value is not included in the comparison. If the constant value does not match the value of the field, the condition shall be considered to be met.
If the matching expression starts with a "#" character (e.g., "#!="), the value of the field is considered to be numeric for the purposes of comparison. Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "&gt; constant"
      - The greater than matching expression tests if the value of the field is lexicographically greater than a specified constant value. The greater than test is case sensitive. 
The leading space character after the "&gt;" and before the constant value is not included in the comparison. 
If the constant value is greater than the value of the field, the condition shall be considered to be met. 
    * - "field" : "#&gt; constant"
      - The numeric greater than matching expression tests if the numeric value of the field is greater than a specified constant value. 
Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "&gt;= constant"
      - The greater than or equals to matching expression tests if the value of the field is lexicographically greater than or equal to a specified constant value. The greater than or equals to test is case sensitive. 
The leading space character after the "&gt;=" and before the constant value is not included in the comparison. 
If the constant value is greater than or equal to the value of the field, the condition shall be considered to be met.
    * - "field" : "#&gt;= constant"
      - The numeric greater than or equals to matching expression tests if the numeric value of the field is greater than or equal to a specified constant value. 
Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "&lt; constant"
      - The less than operator tests if the value of the field is lexicographically less than a specified constant value. The less than test is case sensitive. 
The leading space character after the "&lt;" and before the constant value is not included in the comparison. 
If the constant value is less than the value of the field, the condition shall be considered to be met.
    * - "field" : "#&lt; constant"
      - The numeric less than operator tests if the numeric value of the field is less than a specified constant value.
Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "&lt;= constant"
      - The less than or equals to matching expression tests if the value of the field is lexicographically less than or equal to a specified constant value. The less than or equal test is case sensitive. 
The leading space character after the "&lt;=" and before the constant value is not included in the comparison. 
If the constant value is less than or equal to the value of the field, the condition shall be considered to be met.
    * - "field" : "#&lt;= constant"
      - The numeric less than or equals to matching expression tests if the numeric value of the field is less than or equal to a specified constant value.
Numeric constant strings shall be processed according to the JSON number representation described in :rfc:`4627`. A numeric matching expression shall be considered to be non-matching against a non-numeric field value.
    * - "field" : "starts constant"
      - The starts with matching expression tests if the field value starts with a specified constant value. 
The leading space character after the "starts" and before the constant value is not included in the comparison. The starts with test is case sensitive. 
If the constant value is equal to the start of the value of the field, the condition shall be considered to be met. 
    * - "field" : "!starts constant" 
      - The not starts with matching expression tests if the field value does not start with a specified constant value. 
The leading space character after the "!starts" and before the constant value is not included in the comparison. The not starts with test is case sensitive. 
If the constant value is not equal to the start of the value of the field, the condition shall be considered to be met. 
    * - "field" : "ends constant"
      - The ends with matching expression tests if the field value ends with a specified constant value. 
The leading space character after the "ends" and before the constant value is not included in the comparison. The ends with test is case sensitive. 
If the constant value is equal to the end of the value of the field, the condition shall be considered to be met.
    * - "field" : "!ends constant" 
      - The not ends with matching expression tests if the field value does not end with a specified constant value. 
The leading space character after the "!ends" and before the constant value is not included in the comparison. The not ends with test is case sensitive. 
If the constant value is not equal to the end of the value of the field, the condition shall be considered to be met. 
    * - "field" : "contains constant" 
      - The contains matching expression tests if the field value contains a specified constant value. 
The leading space character after the "contains" and before the constant value is not included in the comparison. The contains test is case sensitive. 
If the constant value is found as a substring within the value of the field, the condition shall be considered to be met. The contains operator is only supported if the cdmi_query_contains capability is present. 
    * - "field" : "!contains constant"
      - The not contains matching expression tests if the field value does not contain a specified constant value. 
The leading space character after the "!contains" and before the constant value is not included in the comparison. The not contains test is case sensitive. 
If the constant value is not found as a substring within the value of the field, the condition shall be considered to be met. The not contains operator is only supported if the cdmi_query_contains capability is present. 
    * - "field" : "tag constant"
      - The tag matching expression tests if the field value contains a specified constant tag value. 
The leading space character after the "tag" and before the constant value is not included in the comparison. The tag test is not case sensitive. 
If the constant value is found as a tag substring within the value of the field, the condition shall be considered to be met. Tag substrings start at the beginning of the value or a ",", and end at the next "," or the end of the string. Whitespace before and after "," characters shall be stripped for the purpose of comparisons. 
Tag matching expressions are only supported if the cdmi_query_tags capability is present.
    * - "field" : "!tag constant" 
      - The not tag matching expression tests if the field value does not contain a specified constant tag value. 
The leading space character after the "!tag" and before the constant value is not included in the comparison. The not tag test is not case sensitive. 
If the constant value is not found as a tag substring within the value of the field, the condition shall be considered to be met. Tag substrings start at the beginning of the value or a ",", and end at the next "," or the end of the string. Whitespace before and after "," characters shall be stripped for the purpose of comparisons. 
Tag matching expressions are only supported if the cdmi_query_tags capability is present. 
    * - "field" : "=~ constant"
      - The regular expression matching expression tests if the field value matches a specified constant regular expression value. 
The leading space character after the "=~" and before the constant value is not included in the comparison. If the regular expression evaluates to true against the value, the condition shall be considered to be met. 
Regular expression strings shall be processed according to the POSIX Extended Regular Expression (ERE) standard, as specified in :ref:`IEEE Std 1003.1`. 
Regex matching expressions are only supported if the cdmi_query_regex capability is present.
    * - "field" : "!~ constant"
      - The not regular expression matching expression tests if the field value does not match a specified constant regular expression value. 
The leading space character after the "!~" and before the constant value is not included in the comparison. If the regular expression evaluates to false against the value, the condition shall be considered to be met. 
Regular expression strings shall be processed according to the POSIX Extended Regular Expression (ERE) standard, as specified in :ref:`IEEE Std 1003.1`. 
Regex matching expressions are only supported if the cdmi_query_regex capability is present. 


All fields in objects that are not included in the scope specification shall be ignored for the purpose of matching objects.

When a URI is used as the constant for the equals and not equals operators against the parentURI, domainURI, and capabilitiesURI, either a URI by path or URI by object ID can be specified and are considered interchangeable. 
<DIV>
#. In a query to find all objects belonging to a specific domain, the following two query scopes are considered identical: 

    .. code-block:: http


    [

        {

            "domainURI" : "== /cdmi_domains/MyDomain/" 

        } 

    ] 

   and 

    [

        {

            "domainURI" : "== /cdmi_objectid/00007E7F001074C86AD256DA5C67180D/" 

        } 

    ] 
</DIV>
<DIV>
#. Likewise, a query to find all objects with a given parent container would have two equivalent forms: 

    .. code-block:: http


    [

        {

            "parentURI" : "== /MyContainer/" 

        } 

    ] 

   and 

    [

        {

            "parentURI" : "== /cdmi_objectid/00007ED900100E358C3B312DB652C201/"  

        } 

    ]

If an object ID is used in a query scope in the objectID field or the parentID field, all object IDs shall be processed such that they are case insensitive.

.. _50532477_76496:
&nbsp;
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532478_76496:
Results Specification
========================================
<DIV>

Introduction
************************

CDMI™ provides a standardized mechanism to define subsets of object contents. This mechanism is known as a CDMI results specification. Results specifications are typically used to provide a CDMI client with a way to indicate on what subset of the contents of CDMI objects it intends to retrieve or operate.

Each JSON object within the results specification represents a set of fields that are returned for each matching object.

The results JSON object shall be constructed using the same structure as is used for CDMI objects. To show this, assume the following result from a CDMI GET for a data object:

    HTTP/1.1 200 OK

    Content-Type: application/cdmi-object

    X-CDMI-Specification-Version: 1.1

    &nbsp;

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007E7F0010EB9092B29F6CD6AD6824",

    	"objectName" : "MyDataObject.txt",

    	"parentURI" : "/MyContainer/",

         "parentID" : "00007E7F00102E230ED82694DAA975D2",

    	"domainURI" : "/cdmi_domains/MyDomain/",

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/",

    	"completionStatus" : "Complete",

    	"mimetype" : "text/plain",

    	"metadata" : {

    		"cdmi_size" : "108263",

    			...

    	},

    	"valuerange" : "0-108262",

    	"value" : "..."

    }
</DIV>
<DIV>

Examples
************************

Each field inside a results specification JSON object indicates that the field shall be included in the results. 
<DIV>
#. The following results specification requests that the objectID and cdmi_size metadata fields be returned in the results:

    .. code-block:: http


    {

        "cdmi_results_specification" : {

            "objectID" : "",

            "metadata" : {

                "cdmi_size" : "" 

            } 

        } 

    } 
</DIV>
<DIV>
#. If an object is matched, the result JSON is enqueued as follows:

    .. code-block:: http


    {

        "objectID" : "00007E7F0010EB9092B29F6CD6AD6824",

        "metadata" : {

            "cdmi_size" : "108263" 

        } 

    } 

For most common use cases, clients request either the objectID, the objectName and parentURI, or all three fields in the cdmi_results_specification. If the parentURI or objectName is requested, the field shall only be returned for objects existing in a container object.
</DIV>
<DIV>
#. To request all metadata items be returned for each matching object, the following cdmi_results_specification shall be used: 

    .. code-block:: http


    {

        "cdmi_results_specification" : {

            "metadata" : "" 

        } 

    }
</DIV>
<DIV>
#. To request all fields and all metadata items be returned for each matching object, the following cdmi_results_specification shall be used:

    .. code-block:: http


    {

        "cdmi_results_specification" : "" 

    }  

The value field is always returned in base 64 encoding when included in a query result, where the valuetransferencoding field indicates the encoding that should be expected if a GET to read the object is performed.

&nbsp;
</DIV>
</DIV>
</DIV>
<DIV>
.. _50532479__Toc127343540:
Logging
========================================
<DIV>

Overview
************************

CDMI™ logging is divided into functional areas, each with differing levels of detail. These areas are:


* object logging,
* security logging, and
* data management logging.


This international standard does not define the format of log messages. It is anticipated that future logging standards will address this area.

A CDMI client may access log data by creating a logging queue that indicates the scope of log messages that the client wishes to receive, as described in :ref:`Logging Queues`. If the user has sufficient permissions to create a logging queue, all log messages to which he or she has subscribed shall be enqueued into the queue, which may be accessed for processing and archival storage.

If multiple logging queues are defined, each logging queue shall get the log entry for a subscribed event. If no logging queues are defined that subscribe to a given log message or class of log messages, these messages do not have to be retained by the cloud storage system.
</DIV>
<DIV>

Object Logging
************************

If the cloud storage system supports logging, then all operations performed on CDMI objects (data objects, container objects, domain objects, queue objects, and capability objects) shall be persistently stored into all defined logging queues.

Log messages shall contain a minimum of the following information, in a format specified by the implementor:


* a timestamp in ISO-8601 format (see :ref:`Time Representations`);
* the domain in which the operation was performed;
* the operation being performed;
* the URI of the object against which the operation was performed;
* the principal of the entity by which the operation was performed; and
* the result of the operation.


Operations logged should include operations performed to a CDMI-exported file system.
</DIV>
<DIV>

Security Logging
************************

All security-sensitive events, including establishing sessions, authenticating and authorizing users, and modifying and delegating domains, shall be logged as security events. Security logging includes managing credentials (i.e., validating revocation lists) and managing users and domains. Security logging should also include out-of-band operations that affect the security of a cloud storage system (e.g., modifying security properties of a CDMI domain via an administrative GUI).  

If the cloud storage system supports a queue type of cdmi_logging_queue and a cdmi_logging_class of cdmi_security_logging as shown in :ref:`Logging Queues`, this metadata indicates that the system supports audit logging. Consequently, the system-wide capability of cdmi_security_audit specified in :ref:`System-Wide Capabilities` of :ref:`Data System Metadata Capabilities` shall be set to "true". Otherwise, cdmi_security_audit shall not be present.
</DIV>
<DIV>

Data Management Logging
************************

In addition to log messages associated with changing metadata when changing data system metadata, logging should also include all conditions where the specified or actual data system metadata for objects change. For example, if the number of requested replicas was changed by a client, this change shall generate a log message indicating this change. A corresponding change in the actual number of replicas by the system shall also generate a log message.

This class of logging shall also contain object holds and retention policy log messages. 
</DIV>
<DIV>
.. _50532479__Ref252787540:
Logging Queues
************************

Logging queues allow CDMI clients to get detailed logging information about the actions related to the operation of a cloud storage system. As queue data is persistent, no session state needs to be retained by the client. If different logging queues are used for different clients, then each client operates independently from the others (e.g., an analysis application may retrieve information about actions performed in a specific domain or set of objects using a logging queue that is uniquely configured to its specific needs).

Logging queues differ from notification queues (see :ref:`Notification Queues`) in that the information provided is at a much more detailed level than notifications and is typically restricted to a smaller, privileged subset of clients.

When a client wishes to receive logging information, it may first check if the system is capable of providing logging by checking for the presence of the cdmi_logging capability in the root container capabilities. If this capability is not present, creating a logging queue shall be successful, but no logging entries shall be enqueued into the logging queue.

When creating a logging queue, the metadata described in :ref:`Required Metadata for a Logging Queue` shall be provided. Attempts to change metadata in th.. list-table shall result in an HTTP status code of ``    :header-rows: 1
    :widths: auto
    :align: center 


403 Forbidden``. Once a logging queue has been created, with the exception of cdmi_queue_type, the metadata items in th.. list-table cannot be changed. cdmi_queue_type can only be removed, indicating to the system that the logging queue shall no longer receive log messages and shall be treated as a regular CDMI queue object.
    :header-rows: 1
    :widths: auto
    :align: center 




.. list-table:: <A NAME="50532479_75529"></A>Required Metadata for a Logging Queue (Sheet 1 of 2)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_queue_type
      - JSON String
      - The queue type indicates how the cloud storage system shall manage the queue object. The type of cdmi_logging_queue is defined for logging queues.
      - Mandatory
    * - cdmi_logging_class
      - JSON Array of JSON Strings
      - Contains a JSON array that indicates which log messages are to be enqueued. Defined values are:


        * cdmi_object_logging - Receive logging messages related to object operations;
        * cdmi_datasystem_logging - Receive logging messages related to data system metadata state changes; and
        * cdmi_security_logging - Receive logging messages related to security events.

Clients may include the desired classes of log messages in the cdmi_logging_class JSON array. If all log messages are desired, an empty JSON array shall be used. 
      - Mandatory
    * - cdmi_scope_specification
      - JSON Array of JSON Objects
      - The scope specification determines the set of objects for which associated log messages shall be enqueued. If logging is desired for all objects, include an empty JSON array. For security logging, the scope specification is ignored. See :ref:`Scope Specification` for how to construct a scope specification.
      - Mandatory

<DIV>
#. An example of the metadata associated with a logging queue is as follows:

    .. code-block:: http


    {

        "metadata" : {

            "cdmi_queue_type" : "cdmi_logging_queue",

            "cdmi_logging_class" : [

                "cdmi_object_logging",

                "cdmi_security_logging" 

            ],

            "cdmi_scope_specification" : [

                {

                    "domainURI" : "== /cdmi_domains/MyDomain/"

                } 

            ]

        } 

    }

When logging messages are dequeued from a logging queue, the contents of each queue value shall contain a JSON object and have a mimetype field value of "application/json". This JSON object contains one or more JSON strings or objects, each representing a single log message.

Log messages are only included in a logging queue if the user who created the logging queue is able to access the object associated with the log message, (i.e., user has any ACE from :ref:`ACE Mask Bits`).
</DIV>
<DIV>
#. If the administrator created the logging queue, then all matching objects, without restriction, are included in the results. If user "jdoe" created the logging queue, then only logging messages for objects that "jdoe" is allowed to access are included in the results.

    .. code-block:: http


:ref:`Logging Status Metadata` describes the system-created metadata that provides details on the status of the logging queue.


.. list-table:: <A NAME="50532479_11459"></A>Logging Status Metadata 
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_logging_status	
      - JSON String
      - A string indicating the state of the logging queue. Defined values are: 


        * Processing - Indicates that the logging queue is scanning for results; 
        * Halted - Indicates that new log messages will no longer be enqueued;
        * Current - Indicates that the logging queue contained all log messages that can be found at this time; and
        * Error - Indicates that the logging queue metadata is not valid, or other errors were encountered that prevented logging messages from being enqueued. Arbitrary vendor-defined text may follow the string "Error".

      - Mandatory

</DIV>
</DIV>
<DIV>

Logging Security Considerations
************************

The timestamp accuracy and integrity of the log entries depend on the accuracy and integrity of the clock that is used to set their timestamp values. Accurate timestamps are essential to troubleshooting, forensic analysis of distributed attacks, dispute resolution, and proof of time-sensitive transactions. In essence, debugging, security, audit, and authentication are founded on the basis of event correlation (i.e., what happened when and whether the action occurred on the client or server side), and these security considerations depend on good time synchronization. 

While specifying the accuracy and integrity of timekeeping is not within the scope of this international standard, to demonstrate that log timestamps are trustworthy, timestamps should be traceable to a standard time, and it should be demonstrated that system time may not be arbitrarily changed.

&nbsp;
</DIV>
</DIV>
<DIV>
.. _50532480__Toc127343486:
Notification Queues
========================================

A cloud storage system may optionally implement notification functionality. The implementation of notification is indicated by the presence of the cloud storage system-wide capabilities for notification and requires support for CDMI™ queues.

Notification queues allow CDMI clients to efficiently discover what changes have occurred to the system. As queue data is persistent, no session state needs to be retained by the client. If different notification queues are used for different clients, then each client operates independently from the others (e.g., a storage management application may use a notification queue to keep its database current without having to do full scans of a container to discover what data objects have been added, modified, or removed).

When a client wishes to receive notifications, it may first check if the system is capable of providing notifications by checking for the presence of the cdmi_notification capability in the root container capabilities. If this capability is not present, creating a notification queue shall be successful, but no notifications shall be enqueued into the notification queue.

To create a notification queue, the client creates a regular CDMI queue and adds metadata instructing the storage system to treat the queue as a notification queue. This added metadata also instructs the system about what types of notifications shall be generated and what information shall be included with each notification.

After the notification queue is created, all subsequent matching events after the queue creation time shall result in notification results being enqueued into the queue. CDMI does not mandate any specific ordering of events, and clients must be able to handle events that arrive out of order.

When creating a notification queue, the metadata described in :ref:`Required Metadata for a Notification Queue` shall be provided. Attempts to change metadata in th.. list-table shall result in an HTTP status code of ``    :header-rows: 1
    :widths: auto
    :align: center 


403 Forbidden``. After a notification queue has been created, with the exception of cdmi_queue_type, the metadata items in th.. list-table cannot be changed. cdmi_queue_type can only be removed, indicating to the system that the notification queue shall no longer receive notifications and shall be treated as a regular CDMI queue object. 
    :header-rows: 1
    :widths: auto
    :align: center 




.. list-table:: <A NAME="50532480_80229"></A>Required Metadata for a Notification Queue (Sheet 1 of 3)
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_queue_type
      - JSON String
      - The queue type indicates how the cloud storage system shall manage the queue object. The type of cdmi_notification_queue is defined for notification queues.
      - Mandatory
    * - cdmi_notification_events
      - JSON Array of JSON Strings
      - The notification events metadata contains a JSON array that indicates which events generate notifications. Defined values are:


        * cdmi_create_processing - Notifications are generated when a new object is created but is still in the "Processing" completion status.
        * cdmi_create_complete - Notifications are generated when a new object is created immediately or when a new object in the process of being created transitions from the "Processing" completion status. When an object transitions from "Processing" completion status, the "cdmi_event_result" is the HTTP result code that would have been returned if the create operation was not delayed.
        * cdmi_read - Notifications are generated when an object is read.
        * cdmi_modify_processing - Notifications are generated when an existing object is modified but is still in the "Processing" completion status.

      - Mandatory
    * - &nbsp;
      - &nbsp;
      - 

        * cdmi_modify_complete - Notifications are generated when an existing object is modified and is in the "Complete" completion status. This notification is also generated when an existing object being modified transitions from "Processing" to "Complete". When an object transitions from "Processing" completion status, the "cdmi_event_result" is the HTTP result code that would have been returned if the modify operation was not delayed.
        * cdmi_rename - Notifications are generated when an object is renamed as part of a move operation. 
        * cdmi_copy - Notifications are generated for the newly created copied object when the copy is completed.
        * cdmi_reference - Notifications are generated when a reference is created.
        * cdmi_delete - Notifications are generated when an object is deleted.
        * cdmi_export - Notifications are generated when a container is exported.
        * cdmi_snapshot - Notifications are generated when a container snapshot is created.
        * &lt;implementor-specific events&gt;

Clients may include the desired notification event types in the cdmi_notification_events JSON array. If all notifications events are desired, an empty JSON array shall be used.
      - &nbsp;
    * - cdmi_scope_specification
      - JSON Array of JSON Objects
      - The scope specification determines the set of objects on which operations trigger the generation of notifications. If notifications are desired for all objects, include an empty JSON array.
See :ref:`Scope Specification` for how to construct a scope specification.
      - Mandatory
    * - cdmi_results_specification
      - JSON Object
      - The results specification contains the JSON fields to be returned for each object that matches the notification scope specification. See :ref:`Results Specification` for how to construct a results specification.
In addition to the fields defined in :ref:`Results Specification`, for notifications, four additional fields are defined:


        * cdmi_event - Indicates the event as specified in the cdmi_notification_events field that triggered the notification;
        * cdmi_event_result - Indicates the status result of the event that triggered the notification. The status is the same as the status that was returned over the HTTP request, i.e., ``200 OK``
, ``404 Not Found``
, etc.;
        * cdmi_event_time - Indicates the time of the event that triggered the notification. The time will be formatted in ISO-8601 time (see :ref:`Time Representations` and :ref:`ISO 8601:2004`); and
        * cdmi_event_user - Indicates the principal (ACL name) of the user that caused the event that triggered the notification. If the system triggered the event, the name will be left as an empty string. 

      - Mandatory

<DIV>
#. The metadata associated with a notification queue is as follows:

    .. code-block:: http


    {

        "metadata" : {

            "cdmi_queue_type" : "cdmi_notification_queue",

            "cdmi_notification_events" : [

                "cdmi_create_complete",

                "cdmi_read",

                "cdmi_modify_complete",

                "cdmi_delete" 

            ],

            "cdmi_scope_specification" : [

                {

                    "domainURI" : "== /cdmi_domains/MyDomain/",

                    "parentURI" : "starts /sandbox",

                    "metadata" : {

                        "cdmi_size" : "&gt;+100000" 

                    } 

                } 

            ],

            "cdmi_results_specification" : {

                "cdmi_event" : "",

                "cdmi_event_result" : "",

                "cdmi_event_time" : "",

                "objectID" : "",

                "metadata" : {

                    "cdmi_size" : "" 

                } 

            } 

        } 

    }

When notification results are stored in a notification queue, each enqueued value shall consist of a JSON object of MIME type "application/json". This JSON object contains the specified values requested in the cdmi_results_specification of the notification queue metadata.
</DIV>
<DIV>
#. A notification result JSON object is as follows:

    .. code-block:: http


    {

        "cdmi_event" : "cdmi_read",

        "cdmi_event_result" : "200 OK",

        "cdmi_event_time" : "2010-11-15T13:12:52.342324Z",

        "objectID" : "00007E7F0010EB9092B29F6CD6AD6824",

        "metadata" : {

            "cdmi_size" : "108263" 

        } 

    }

Objects shall only be included in the notification results if the user who created the notification queue is able to read the matching object.

If the administrator created the notification queue, then all matching objects that the administrator is allowed to read are included in the results. If user "jdoe" created the notification queue, then only matching objects that "jdoe" is allowed to read are included in the results.

:ref:`Notification Status Metadata` describes the system-created metadata that provides details on the status of the notification queue.


.. list-table:: <A NAME="50532480_20063"></A>Notification Status Metadata
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_notification_status
      - JSON String
      - A string indicating the state of the notification queue. Defined values are: 


        * Processing - Indicates that the notification queue is scanning for results; 
        * Halted - Indicates that new notifications will no longer be enqueued;
        * Current - Indicates that the notification queue contained all notifications that can be found at this time; and
        * Error - Indicates that the notification queue metadata is not valid, or other errors were encountered that prevented notification messages from being enqueued. Arbitrary vendor-defined text may follow the string "Error". 

If this metadata item does not exist, then notifications have not yet started being enqueued.
      - Mandatory

</DIV>
</DIV>
<DIV>
.. _50532481__Toc127343489:
Query Queues
========================================
<DIV>

Overview
************************

A cloud storage system may optionally implement metadata and/or full-text query functionality. The implementation of query is indicated by the presence of the cloud storage system-wide capabilities for query and requires support for CDMI™ queues.

Query queues allow CDMI clients to efficiently discover what content matches a given set of metadata query criteria or full-content search criteria. Clients create or update a query queue by specifying metadata that defines the matching criteria (known as the query scope), along with what results should be returned for matching objects (known as the query results). The cloud service shall then perform the query using the content existing at the time the query is being processed, storing the query results in the query queue. As query results are found, they are added to the queue, and when the query is complete, the cdmi_query_status metadata of the queue is changed to indicate that the query has completed. Any matching objects created or modified while the query is being performed may or may not be included in the query results (e.g., as a consequence of eventual consistency).

When a client wishes to perform queries, it may first check if the system is capable of providing query functionality by checking for the presence of the cdmi_query capability in the root container capabilities. If this capability is not present, creating a query queue shall be successful, but no query results shall be enqueued into the query queue.

When creating a query queue, the metadata described in :ref:`Required Metadata for a Query Queue` shall be provided. Attempts to change metadata in th.. list-table shall result in an HTTP status code of ``    :header-rows: 1
    :widths: auto
    :align: center 


403 Forbidden``. After a query queue has been created, with the exception of cdmi_queue_type, the metadata items in th.. list-table cannot be changed. If the value of cdmi_queue_type is changed from "cdmi_query_queue", this change indicates to the system that an in-process query shall be stopped, the query queue shall no longer receive query results, and the query queue shall be treated as a regular CDMI queue object. To start a new query with an existing queue, the value of the cdmi_queue_type shall be changed back to "cdmi_query_queue". This international standard does not define a mechanism to pause a running query or resume a stopped query. 
    :header-rows: 1
    :widths: auto
    :align: center 




.. list-table:: <A NAME="50532481_78662"></A>Required Metadata for a Query Queue 
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_queue_type
      - JSON String
      - The queue type indicates how the cloud storage system shall manage the queue object. The type of cdmi_query_queue is defined for query queues.
      - Mandatory
    * - cdmi_scope_specification
      - JSON Array of JSON Objects
      - The scope specification determines which objects are included in the query results. This scope specification is similar to a "WHERE" clause in SQL-like languages. To query all objects, specify an empty JSON array. See :ref:`Scope Specification`
 for how to construct a scope specification.
      - Mandatory
    * - cdmi_results_specification
      - JSON Object
      - The results specification contains the JSON fields to be returned for each object that matches the query. This results specification is similar to a "SELECT" clause in SQL-like languages. See :ref:`Results Specification`
 for how to construct a results specification.
      - Mandatory

<DIV>
#. An example of the metadata associated with a query queue is as follows:

    .. code-block:: http


    {

        "metadata" : {

            "cdmi_queue_type" : "cdmi_query_queue",

            "cdmi_scope_specification" : [

                {

                    "domainURI" : "== /cdmi_domains/MyDomain/",

                    "parentURI" : "starts /sandbox",

                    "metadata" : {

                        "cdmi_size" : "#&gt; 100000" 

                    } 

                } 

            ],

            "cdmi_results_specification" : {

                "objectID" : "",

                "metadata" : {

                    "cdmi_size" : "" 

                } 

            } 

        }

    }

When results are stored in a query queue, each enqueued value shall consist of a JSON object of MIME type "application/json". This JSON object contains the specified values requested in the cdmi_results_specification of the query queue metadata. 
</DIV>
<DIV>
#. An example of a query result JSON object is as follows:

    .. code-block:: http


    {

        "objectID" : "00007E7F0010EB9092B29F6CD6AD6824",

        "metadata" : {

            "cdmi_size" : "108263" 

        } 

    } 

:ref:`Query Status Metadata` describes the system-created metadata that provides details on the status of the query queue.


.. list-table:: <A NAME="50532481_34298"></A>Query Status Metadata
    :header-rows: 1
    :widths: auto
    :align: center 


    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_query_status
      - JSON String
      - When present, this metadata item indicates the state of the query queue. Defined values are: 


        * Processing - Indicates that the query queue is scanning for results; 
        * Halted - Indicates that new query results will no longer be enqueued;
        * Current - Indicates that the query queue contained all query results that can be found at this time; and
        * Error - Indicates that the query queue metadata was not valid, or other errors were encountered that prevented all query results from being enqueued. Arbitrary vendor-defined text may follow the string "Error".

      - Mandatory


Objects shall only be included in the query results if the user who created the query queue is able to read the matching objects or metadata.
</DIV>
<DIV>
#. If the administrator created the query queue, then all matching objects that the administrator is allowed to read are included in the results. If user "jdoe" created the query queue, then only matching objects that "jdoe" is allowed to read are included in the results.

    .. code-block:: http

</DIV>
</DIV>
<DIV>
.. _50532481_33287:
Extending CDMI Query
************************

An implementor of a CDMI server may extend CDMI query by adding vendor-specific matching expressions. When an implementor adds vendor-specific metadata fields, these fields shall be queried using the standard query queue functionality. 

An implementor of a CDMI server may extend CDMI query by allowing the creation of vendor-specific query queues with a type other than cdmi_query_queue. 

&nbsp;
<OL>
<LI CLASS="A1">
<BR>
(informative)<BR>
Extensions</LI>
</OL>
<DIV>
<H6 CLASS="A2">
Summary Metadata for Bandwidth</H6>
<DIV>
<H6 CLASS="A3">
Overview</H6>

Domain summaries provide summary measurement information about domain usage and billing. Some systems may track additional usage and billing information related to network bandwidth. This extension proposes a set of additional, optional contents for domain summary objects.
</DIV>
<DIV>
<H6 CLASS="A3">
Changes to CDMI 1.1</H6>

The changes proposed are a set of additional, optional contents for domain summary objects.
<OL>
#. Insert into :ref:`Terms`.
</OL>
3.x
private network segment
     a single IP address or range of IP addresses that are considered internal (e.g., LAN)
3.x
public network segment
     a single IP address or range of IP addresses that are considered external (e.g., WAN)
<OL>
#. A.. list-table entries to the end of :ref:`Contents of Domain Summary Objects` in :ref:`Domain Object Summaries` as follows:
    :header-rows: 1
    :widths: auto
    :align: center 



    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_summary_network_bytes
      - JSON String
      - Total number of bytes read/written to/from public/private network segments
      - Optional
    * - cdmi_summary_reads_private
      - JSON String
      - Total number of bytes read from private network segment
      - Optional
    * - cdmi_summary_reads_private_min
      - JSON String
      - Minimum number of bytes read from private network segment for the given interval
      - Optional
    * - cdmi_summary_reads_private_max
      - JSON String
      - Maximum number of bytes read from private network segment for the given interval
      - Optional
    * - cdmi_summary_reads_private_avg
      - JSON String
      - Average number of bytes read from private network segment for the given interval
      - Optional
    * - cdmi_summary_writes_private
      - JSON String
      - Total number of bytes written to private network segment
      - Optional
    * - cdmi_summary_writes_private_min
      - JSON String
      - Minimum number of bytes written to private network segment for the given interval
      - Optional
    * - cdmi_summary_writes_private_max
      - JSON String
      - Maximum number of bytes written to private network segment for the given interval
      - Optional
    * - cdmi_summary_writes_private_avg
      - JSON String
      - Average number of bytes written to private network segment for the given interval
      - Optional
    * - cdmi_summary_reads_public
      - JSON String
      - Total number of bytes read from public network segment
      - Optional
    * - cdmi_summary_reads_public_min
      - JSON String
      - Minimum number of bytes read from public network segment for the given interval
      - Optional
    * - cdmi_summary_reads_public_max
      - JSON String
      - Maximum number of bytes read from public network segment for the given interval
      - Optional
    * - cdmi_summary_reads_public_avg
      - JSON String
      - Average number of bytes read from public network segment for the given interval
      - Optional
    * - cdmi_summary_writes_public
      - JSON String
      - Total number of bytes written to public network segment
      - Optional
    * - cdmi_summary_writes_public_min
      - JSON String
      - Minimum number of bytes written to public network segment for the given interval
      - Optional
    * - cdmi_summary_writes_public_max
      - JSON String
      - Maximum number of bytes written to public network segment for the given interval
      - Optional
    * - cdmi_summary_writes_public_avg
      - JSON String
      - Average number of bytes written to public network segment for the given interval
      - Optional
    * - cdmi_summary_reads_total
      - JSON String
      - Total number of bytes read from both public and private network segments
      - Optional
    * - cdmi_summary_writes_total
      - JSON String
      - Total number of bytes written to both public and private network segments
      - Optional
</TABLE>
</OL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="A2">
Expiring Access Control Entries (ACEs)</H6>
<DIV>
<H6 CLASS="A3">
Overview</H6>

A common trait of cloud storage services is the ability to share an object with other clients for a limited time. This extension adds an attribute of ACEs used in ACLs that imposes a time limit (expiration) on the ACE. Once the ACE expires, the ACE is no longer  valid or included in the authorization calculation for the object.
</DIV>
<DIV>
<H6 CLASS="A3">
Changes to CDMI 1.1</H6>
<OL>
#. Insert into :ref:`ACL Evaluation`:
</OL>
<P CLASS="Body-Indent">
After the bullet item:</P>


* ACEs that do not refer to the principal P requesting the operation are ignored.

<P CLASS="Body-Indent">
Insert bullet:</P>


* ACEs that have an expiration value less than the current time are ignored.
#. Change :ref:`ACL Evaluation`:

<P CLASS="Body-Indent">
Original text:</P>

    ACE = { acetype , identifier , aceflags , acemask , acetime }
<P CLASS="Body-Indent">
Revised text:</P>

    ACE = { acetype , identifier , aceflags , acemask , acetime, expiration }
<OL>
#. Insert into :ref:`ACL Evaluation` after "``acemask = uint_t | acemaskstring``":
</OL>

    expiration = uint_t
<OL>
#. Insert into :ref:`ACL Evaluation` after "When ACE masks...":
</OL>

   When ACE expiration is presented in string format, it shall be specified in ISO-8601 point-in-time format as described in :ref:`Time Representations`.
<OL>
#. Insert a new subclause 16.1.x - ACE Expiration.
</OL>

   An ACE may have an optional expiration associated with it. The expiration is a point-in-time value, in ISO-8601 point-in-time format, as described in :ref:`Time Representations`, which specifies that the ACE is no longer valid and shall be ignored after the time specified. 
</DIV>
</DIV>
<DIV>
<H6 CLASS="A2">
Group Storage System Metadata</H6>
<DIV>
<H6 CLASS="A3">
Overview</H6>

ACLs in CDMI can refer to the owner of an object by specifying an ACE Who of "OWNER@". This reference corresponds to the contents of the cdmi_owner storage system metadata. However, no cdmi_group storage system metadata corresponds to an ACE Who of "GROUP@".

This extension defines a new storage system metadata item, cdmi_group, that allows an object to be associated with a group for ACL evaluation purposes.
</DIV>
<DIV>
<H6 CLASS="A3">
Changes to CDMI 1.1</H6>
<OL>
#. Add.. list-table enty to the end of :ref:`Capabilities for Data System Metadata` in :ref:`Data System Metadata Capabilities`.
    :header-rows: 1
    :widths: auto
    :align: center 



    * - Capability Name
      - Type
      - Definition
    * - cdmi_group
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system supports group storage system metadata to indicate a group associated with the object.
</TABLE>
#. Add.. list-table entry below "cdmi_owner" in :ref:`Storage System Metadata` of :ref:`Support for Storage System Metadata`.
    :header-rows: 1
    :widths: auto
    :align: center 



    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_group
      - JSON String
      - The name of the group that is associated with the object.
      - Optional
</TABLE>
</OL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="A2">
Versioning</H6>
<DIV>
<H6 CLASS="A3">
Overview</H6>

This CDMI extension adds the ability to request that data objects be versioned and defines how versions are accessed and managed. Version-enabled data objects provide access to and retention of historical versions of a data object and can provide compliance functionality and revision history. Version-enabled data objects also help applications handle multiple concurrent writers in disconnected distributed environments.

Versioning is based on the snapshot concept introduced in CDMI 1.0 (see :ref:`CDMI Snapshots`) and follows the same architectural pattern. It should be reviewed in this context.
<DIV>
<H6 CLASS="Note">
Reviewers: Please start reading at :ref:`23 Data Object Versions` on :ref:`23 Data Object Versions`.</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="A3">
Changes to  CDMI 1.1</H6>
<OL>
#. Insert into :ref:`Terms`.
</OL>
3.x
current data object version
     the most recent version of a version-enabled data object
3.x
data object version
     either the current data object version or an historical data object version
3.x
historical data object version
     a non-current state of a version-enabled data object
3.x
version-enabled data object
     a CDMI data object with versioning enabled
<OL>
#. Insert into :ref:`Examples` at the end of the clause.
</OL>
<DIV>
#.  GET to the URI to read a newly-created data object with a current version:

    .. code-block:: http


    GET /MyContainer/MyVersionedDataObject.txt HTTP/1.1

    Host: cloud.example.com 

    Accept: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK 

    Content-Type: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

    

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007ED900100DA32EC94351F8970400",

    	"objectName" : "MyVersionedDataObject.txt",

    	"parentURI" : "/MyContainer/",

    	"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    	"domainURI" : "/cdmi_domains/MyDomain/", 

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/", 

    	"completionStatus" : "Complete", 

    	"mimetype" : "text/plain", 

    	"metadata" : {

    		"cdmi_size" : "33",

    		"cdmi_versioning" : "user",

    		"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    		"cdmi_version_current" : "/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA",

    		"cdmi_version_oldest" : [

    			"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    		],

    		...

    	},

    	"valuerange" : "0-32", 

    	"valuetransferencoding" : "utf-8", 

    	"value" : "First version of this Data Object"

    }
</DIV>
<DIV>
#.  GET to the URI to read a data object with two historical versions:

    .. code-block:: http


    GET /MyContainer/MyVersionedDataObject.txt HTTP/1.1

    Host: cloud.example.com 

    Accept: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK 

    Content-Type: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

    

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007ED900100DA32EC94351F8970400",

    	"objectName" : "MyDataObject.txt",

    	"parentURI" : "/MyContainer/",

    	"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    	"domainURI" : "/cdmi_domains/MyDomain/", 

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/", 

    	"completionStatus" : "Complete", 

    	"mimetype" : "text/plain", 

    	"metadata" : {

    		"cdmi_size" : "33",

    		"cdmi_versioning" : "user",

    		"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    		"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    		"cdmi_version_oldest" : [

    			"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    		],

    		...

    	},

    	"valuerange" : "0-32", 

    	"valuetransferencoding" : "utf-8", 

    	"value" : "Third version of this Data Object"

    }
</DIV>
<DIV>
#.  GET to the URI of a data object version:

    .. code-block:: http


    GET /cdmi_objectid/00007ED9001005192891EEBE599D94BB HTTP/1.1

    Host: cloud.example.com 

    Accept: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

   The following shows the response.

    HTTP/1.1 200 OK 

    Content-Type: application/cdmi-object 

    X-CDMI-Specification-Version: 1.1

    

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007ED9001005192891EEBE599D94BB",

    	"objectName" : "MyVersionedDataObject.txt",

    	"parentURI" : "/MyContainer/",

    	"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    	"domainURI" : "/cdmi_domains/MyDomain/", 

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/dataobject_version/", 

    	"completionStatus" : "Complete", 

    	"mimetype" : "text/plain", 

    	"metadata" : {

    		"cdmi_size" : "34",

    		"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    		"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    		"cdmi_version_oldest" : [

    			"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    		],

    		"cdmi_version_parent" : "/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA",

    		"cdmi_version_children" : [

    			"/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC"

    		],

    		...

    	},

    	"valuerange" : "0-33", 

    	"valuetransferencoding" : "utf-8", 

    	"value" : "Second version of this Data Object"

    }

    &nbsp;
<OL>
#. Insert into :ref:`Data System Metadata Capabilities`, :ref:`Capabilities for Data System Metadata`.

    * - Capability Name
      - Type
      - Description
    * - cdmi_versioning
      - JSON Array of JSON Strings
      - If present, this capability indicates that the cloud storage system shall support versioning of data objects and contains a list of which versioning behaviors are supported. The following values are defined:


        * "value" indicates that the system shall support the versioning of the object value.
        * "user" indicates that the system shall support the versioning of the object value and user metadata.
        * "all" indicates that the system shall support the versioning of all updates made to a data object.

When present, the system shall support the following storage system metadata: cdmi_version_object, cdmi_version_current, cdmi_version_oldest, cdmi_version_parent, and cdmi_version_children as indicated by the corresponding storage system metadata capabilities.
    * - cdmi_versions_count
      - JSON String
      - If present, this capability specifies the maximum number of historical versions that may be specified. If absent, restrictions on the number of historical versions specified shall be ignored.
    * - cdmi_version_age
      - JSON String
      - If present, this capability specifies the maximum age of historical versions that may be specified. If absent, restrictions on the age of historical versions specified shall be ignored.
    * - cdmi_versions_size
      - JSON String
      - If present, this capability specifies the maximum total size of historical versions that may be specified. If absent, restrictions on the size of historical versions specified shall be ignored.
</TABLE>
#. Insert into :ref:`Support for Storage System Metadata`, :ref:`Storage System Metadata`.

    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_version_object
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_version_object storage system metadata for each version-enabled data object and data object version.
      - Conditional
    * - cdmi_version_current
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_version_current storage system metadata for each version-enabled data object and data object version.
      - Conditional
    * - cdmi_version_oldest
      - JSON Array of JSON Strings
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_version_oldest storage system metadata for each version-enabled data object and data object version.
      - Conditional
    * - cdmi_version_parent
      - JSON String
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_version_parent storage system metadata for each data object version that has a previous version.
      - Conditional
    * - cdmi_version_children
      - JSON Array of JSON Strings
      - If present and "true", this capability indicates that the cloud storage system shall generate a cdmi_version_children storage system metadata for each data object version.
      - Conditional
</TABLE>
#. Insert into :ref:`Support for Data System Metadata`, :ref:`Data System Metadata`.

    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_versioning
      - JSON String
      - If present, this metadata item indicates that versioning is requested to be enabled for the data object.


        * If set to the value "value", versions shall be created when the value is updated.
        * If set to the value "user", versions shall be created when the value and/or user metadata is updated.
        * If set to the value "all", versions shall be created when any update is performed against the version-enabled data object.

This data system metadata item shall not be present in data object versions.
      - Optional
    * - cdmi_versions_count
      - JSON String
      - This metadata item contains the maximum number of historical versions requested to be retained.


        * If cdmi_versions_count is not present, no limit should be placed on the number of versions that are retained.
        * If cdmi_versions_count is present and has a value of zero, only the current version should be retained.
        * If cdmi_versions_count is present and has a value greater than zero, up to the specified number of historical versions should be retained.
        * If the number of historical versions exceeds the value specified, historical versions should be deleted from the oldest to the newest until the number of historical versions equals the value contained in cdmi_versions_count.

      - Optional
    * - cdmi_versions_age
      - JSON String
      - This metadata item contains the maximum age of the oldest historical version requested to be retained, specified as the number of seconds before the current time.


        * If cdmi_versions_age is not present, no limit should be placed on the age of versions that are retained.
        * If cdmi_versions_age is present, historical versions should be retained until their age is greater than the value contained in cdmi_versions_age.
        * If the age of a historical version exceeds the value specified, that historical version should be deleted.

      - Optional
    * - cdmi_versions_size
      - JSON String
      - This metadata item contains the maximum amount of space requested to be used to retain historical versions, specified in bytes.


        * If "cdmi_versions_size is not present, no limit should be placed on the size of versions that are retained.
        * If cdmi_versions_size is present, historic versions should be retained until the total storage consumption of the historical versions exceeds the value contained in cdmi_versions_size.
        * If the total size consumed by historical versions exceeds the value specified, historical versions should be deleted from the oldest to the newest until the total storage consumption of historical versions is equal or less than the value contained in cdmi_versions_count.

      - Optional
</TABLE>
#. Insert into :ref:`Support for Provided Data System Metadata`, :ref:`Provided Values of Data Systems Metadata Items`.

    * - Metadata Name
      - Type
      - Description
      - Requirement
    * - cdmi_versioning_provided
      - JSON String
      - Contains the value "value", "user", or "all" if versioning is enabled for the data object.
      - Conditional
    * - cdmi_versions_count_provided
      - JSON String
      - Contains the maximum number of historical versions that will be retained.
      - Optional
    * - cdmi_versions_age_provided
      - JSON String
      - Contains the oldest age of a historical version that will be retained, in seconds before the current time.
      - Optional
    * - cdmi_versions_size_provided
      - JSON String
      - Contains the maximum amount of space that can be used to retain historical versions, in bytes.
      - Optional
</TABLE>
#. Insert new clause after :ref:`Query Queues`.
</OL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23	<A NAME="50532484_74880"></A>Data Object Versions</H6>
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.1	Overview</H6>

Version-enabled data objects allow the previous state of a data object to be retained when an update is performed. In a non-version-enabled data object, each update changes the state of the object, and the previous state is lost. This state change is shown in :ref:`Updates to a Non-Version-Enabled Data Object`.


<H6 CLASS="Figure-Caption">
.. _50532484_54517:
Updates to a Non-Version-Enabled Data Object</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-13.gif" ALT="">
</DIV>
</TABLE>

When a data object has versioning enabled, each update creates a new "current version" with the same contents of the version-enabled data object, and the previous current version becomes a historical version. All versions can be accessed via separate URIs and are immutable. The version-enabled data object continues to be mutable and has the same behaviors to clients as a non-version-enabled data object. This behavior is shown in :ref:`Updates to a Version-Enabled Data Object` from the perspective of a client.


<H6 CLASS="Figure-Caption">
.. _50532484_93771:
Updates to a Version-Enabled Data Object</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-14.gif" ALT="">
</DIV>
</TABLE>

Using this approach, CDMI clients that are not aware of versioning can continue to access version-enabled data objects the same way as non-version-enabled data objects, while CDMI clients that are aware of versioning can access and manage the immutable versions associated with the version-enabled data object.

Versioning is enabled for a data object by adding a data system metadata item that indicates that versioning is desired.

Version-enabled data objects and all associated versions contain additional storage system metadata items. These metadata items allow a client to discover the versions that are associated with a version-enabled data object and to iterate through these versions. 

The maximum number of versions to be retained, maximum age of versions to be retained, and the maximum space that can be consumed by versions is controlled by data system metadata.

When a data object is version enabled, it always contains at least one version, the "current version". The current version has the same contents as the version-enabled data object but has a different identifier (URI and Object Identifier) and is immutable. When a version-enabled data object is changed, a new current version is created, and the previous current version becomes a historical version.

Versioning has multiple client use cases:


* Clients that need to preserve all data written to a data object over time can use versions to retain all updates made to a data object.
* Clients can restore the contents of a historical version by copying it to the version-enabled data object.
* Clients that retrieve a large data object across multiple parallel or sequential transactions or that need to be able to resume a retrieval at a later time can retrieve the URI for the current version of the data object. Clients can then use that URI to retrieve the data object itself. As the current version is immutable and retains its identifier, even if an update occurs (where the current version becomes a historical version), the client will always receive the same results and will not receive a mixture of the older and newer data object contents.
* Clients can iterate through historical versions to detect where concurrent updates have occurred and can access any overwritten data.
* Distributed CDMI implementations can also use versions to merge concurrent changes made on different, eventually consistent nodes without resulting in data loss.

</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.2	Traversing Version-Enabled Data Objects</H6>

Version-enabled data objects have multiple metadata items that allow a client to traverse through the data object versions.

When a client enables versioning for a data object, the following metadata items shall be added to the version-enabled data object:


* a cdmi_version_object metadata item that contains the URI to the corresponding version-enabled data object. This metadata item allows a client to detect that a given object is a version-enabled data object and not a data object version.
* a cdmi_version_current field that contains the URI to the current version of the version-enabled data object.
* a cdmi_version_oldest field that contains the URI of one or more of the oldest versions. More than one version can exist in this metadata item as explained in :ref:`23.3 Concurrent Updates and Version-Enabled Data Objects`.


Each data object version shall contain the above three fields, with the same values as found in the version-enabled data object. Each data object version shall also contain the following two fields:


* a cdmi_version_parent field that contains the URI of the previous version. If the data object version does not have a parent, this field is omitted.
* cdmi_version_children field that contains the URI
* s of the versions created by modifying this version. If the data object version does not have any children, this metadata item shall be empty.


To visualize how these fields allow a client to traverse data object versions, the linkages between the version-enabled data object and data object versions in the final state of :ref:`Updates to a Version-Enabled Data Object` is shown in :ref:`Linkages Between a Version-Enabled Data Object and Data Object Versions`.


<H6 CLASS="Figure-Caption">
.. _50532484_65512:
Linkages Between a Version-Enabled Data Object and Data Object Versions</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-15.gif" ALT="">
</DIV>
</TABLE>

A client accessing the version-enabled data object (/b.txt) can traverse to the current version and to the oldest version.

A client accessing a data object version can traverse to the version-enabled data object, to the current version, to the parent version, to child versions, and to the oldest version.
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
.. _50532484_86917:
23.3	Concurrent Updates and Version-Enabled Data Objects</H6>

When multiple concurrent updates are performed against a version-enabled data object, each update is performed against the state of the object at the time the update starts. The change to the state resulting from the update to the object becomes visible to clients at the time the update completes.

Two different types of concurrent updates can occur: overlapping updates and nested updates. :ref:`Overlapping Concurrent Updates` and :ref:`Linkages for Overlapping Updates` show the update sequence and resulting version linkages for overlapping updates:


<H6 CLASS="Figure-Caption">
.. _50532484_81844:
Overlapping Concurrent Updates</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-16.gif" ALT="">
</DIV>
</TABLE>


<H6 CLASS="Figure-Caption">
.. _50532484_62039:
Linkages for Overlapping Updates</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-17.gif" ALT="">
</DIV>
</TABLE>

In the sequence shown in :ref:`Overlapping Concurrent Updates`, both the "Second" and "Third" updates are performed against the "First" state. As the "Third" update completes last, it becomes the current version. In this example, historical version 501 would have two children, versions 502 and 503. Both versions 502 and 503 would have the same parent 501.

:ref:`Nested Concurrent Updates` and :ref:`Linkages for Nested Updates` show the update sequence and resulting version linkages for nested updates:


<H6 CLASS="Figure-Caption">
.. _50532484_86134:
Nested Concurrent Updates</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
v</H6>
<DIV>
<IMG SRC="CDMI_Spec-18.gif" ALT="">
</DIV>
</TABLE>


<H6 CLASS="Figure-Caption">
.. _50532484_13363:
Linkages for Nested Updates</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-19.gif" ALT="">
</DIV>
</TABLE>

In the sequence shown in Figure 16, both the "Second" and "Third" updates are performed against the "First" state. As the "Second" update completes last, it becomes the current version. In this example, historical version 501 would have two children, versions 502 and 503. Both versions 502 and 503 would have the same parent 501.

Both of these data structures are equivalent, with the only difference being which update completed last.
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.4	Capabilities for Version-Enabled Data Objects</H6>

The relationship between version-enabled data objects, data object versions, and capabilities is shown in :ref:`Version to capabilityURI Relationships`.


<H6 CLASS="Figure-Caption">
.. _50532484_31064:
Version to capabilityURI Relationships</H6>
</CAPTION>
    * - <H6 CLASS="NoSpace">
&nbsp;</H6>
<DIV>
<IMG SRC="CDMI_Spec-20.gif" ALT="">
</DIV>
</TABLE>

Data object versions are immutable but may be deleted by a client or by the system, depending on the data system metadata specified.
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.5	Updates Triggering Version Creation</H6>

If versioning is enabled by setting the value of the cdmi_versions metadata item in the version-enabled data object to "value", the following updates will trigger the creation of a new version:


* changing the mimetype,
* changing the value, or
* changing the valuetransferencoding.


If versioning is enabled by setting the value of the cdmi_versions metadata item in the version-enabled data object to "user", the following updates will trigger the creation of a new version:


* changing the mimetype,
* changing the value,
* changing the valuetransferencoding, or
* adding, modifying, or removing user metadata.


If versioning is enabled by setting the value of the cdmi_versions metadata item in the version-enabled data object to "all", then all updates to the data object will trigger the creation of a new version.

The effective ACL, owner, and domain of the data object versions shall be the ACL, owner, and domain of the version-enabled data object.

Modifications performed with the X-CDMI-Partial header shall not trigger the creation of a new version until the completionStatus is changed from "Processing" to "Complete".
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.6	Operations against Version-Enabled Data Objects</H6>

Moving a version-enabled data object within a system is considered to be an update to the name and/or parentURI fields.

Moving a version-enabled data object between systems moves all data object versions associated with the version-enabled data object and preserves all identifiers. If the destination name and/or URI are different, the move is considered to be an update to the name and/or parentURI fields.

Copying a version-enabled data object shall only copy the version-enabled data object itself. Versions of the version-enabled data object are not copied.

Deleting a version-enabled data object shall also delete all versions associated with that version-enabled data object.

Disabling versioning for a version-enabled data object shall preserve all versions. Previously existing versioning metadata shall remain present while versioning is disabled. Re-enabling versioning for a data object that previously was version-enabled shall result in the creation of a new current version.

If a version-enabled data object is placed under retention or hold, the retention behaviors of the version-enabled data object shall be applied to the data object versions.

No additional log messages or notifications are defined for version-enabled data objects. When a version-enabled data object is updated, an additional creation log message and/or notification message shall be generated for the created data object version. Likewise, when a data object version is accessed or deleted, a log and/or notification message is generated.

If a limited number, size, or age for versions is requested and a change to a version-enabled data object results in a version being automatically deleted, then the system shall generate a corresponding deletion log and/or notification message for the deleted data object version.
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.7	Operations against Data Object Versions</H6>

A data object version is presented to the client as a standard CDMI data object.

Moving, copying over, deserializing over, and updating a data object version shall not be permitted and shall result in an HTTP status code of ``403 Forbidden``.

Copying a data object version is permitted. For example, to promote a version to become the current version of a version-enabled data object, the URI of the data object version is used in the copy field when performing an update to the URI of the version-enabled data object. Updates can also be performed as part of the copy operation.

Deleting a historical data object version shall be permitted if the client has ACL permissions to delete the version-enabled data object and the version-enabled data object.

Deleting the current version of a version-enabled data object shall revert the current version to the current version's parent. If there is no parent version, deleting the current version shall result in an HTTP status code of ``403 Forbidden``.

When an intermediate historical version is deleted, the parent and children metadata items of the parent and all child data object versions of the data object version being deleted must be updated. 
<DIV>
<H6 CLASS="Example">
In a version chain "C" -&gt; "B" -&gt; "A", where "C" is the newest and "A" is the oldest, deleting version "B" shall produce the following results:</H6>


* The cdmi_version_parent metadata item of "C" is set to the URI contained in the cdmi_version_parent metadata item of "B".
* The URI of "B" in the cdmi_version_children metadata item of "A" is replaced with the URIs contained in the cdmi_version_children metadata item of "B".


In pseudocode, the above translates to:

   C-&gt;cdmi_version_parent = B-&gt;cdmi_version_parent

   A-&gt;cdmi_version_children[B] = B-&gt;cdmi_version_children

   Delete B

If the oldest version of a version-enabled data object is deleted and there are two or more children of that version, both of the children of the deleted oldest version will become the new oldest version.

When accessing a data object version, the cdmi_acount and cdmi_atime of the data object version shall be updated if present.

When accessing a historical version of a version-enabled data object, the ACL, owner, and domainURI of the version-enabled data object shall be in effect.

Standard log and notification messages are sent when data object versions are accessed and deleted.
</DIV>
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.8	Query of Data Object Versions</H6>

As data object versions are regular CDMI objects, they will be included in query results unless explicitly excluded.

Querying for data object versions is performed by including the scope:

    "metadata" : 

    {

    	"cdmi_version_children" : "*"

    }

Querying for version-enabled data objects (but not their versions) is performed by including the scope:

    "metadata" : 

    {

    	"cdmi_versioning" : "*"

    }

Querying for non-versioned data objects with no versions is performed by including the scope:

    "metadata" : 

    {

    	"cdmi_version_current" : "!*"

    }

Querying for non-versioned data objects with versions is performed by including the scope:

    "metadata" : 

    {

    	"cdmi_versioning" : "!*",

    	"cdmi_version_current" : "*"

    }
</DIV>
<DIV>
<H6 CLASS="Body-Text-Head">
23.9	Version-Enabled Data Object Serialization</H6>

Serializing a version-enabled data object shall serialize the data object, the versioning-related metadata, the current version, and all historical versions. The current version and all historical versions shall be serialized as data objects contained within a JSON array. These data objects shall replace the contents of the value field of the serialized representation of the version-enabled data object.
<DIV>
<H6 CLASS="Example">
	A version-enabled data object with three versions is serialized.</H6>

    {

    	"objectType" : "application/cdmi-object",

    	"objectID" : "00007ED900100DA32EC94351F8970400",

    	"objectName" : "MyVersionedDataObject.txt",

    	"parentURI" : "/MyContainer/",

    	"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    	"domainURI" : "/cdmi_domains/MyDomain/", 

    	"capabilitiesURI" : "/cdmi_capabilities/dataobject/", 

    	"completionStatus" : "Complete", 

    	"mimetype" : "text/plain", 

    	"metadata" : {

    		"cdmi_size" : "33",

    		"cdmi_versioning" : "user",

    		"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    		"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    		"cdmi_version_oldest" : [

    			"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    		],

    		...

    	},

    	"value" : [

    		{

    			"objectType" : "application/cdmi-object",

    			"objectID" : "00007ED90010F077F4EB1C99C87524CC",

    			"objectName" : "MyVersionedDataObject.txt",

    			"parentURI" : "/MyContainer/",

    			"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    			"domainURI" : "/cdmi_domains/MyDomain/", 

    			"capabilitiesURI" : "/cdmi_capabilities/dataobject/dataobject_version/", 

    			"completionStatus" : "Complete", 

    			"mimetype" : "text/plain", 

    			"metadata" : {

    				"cdmi_size" : "33",

    				"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    				"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    				"cdmi_version_oldest" : [

    					"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    				],

    				"cdmi_version_parent" : "/cdmi_objectid/00007ED9001005192891EEBE599D94BB",

    				"cdmi_version_children" : [

    				],

    				... 

    			},

    			"valuerange" : "0-32", 

    			"valuetransferencoding" : "utf-8", 

    			"value" : "Third version of this Data Object"

    		},

    		{

    			"objectType" : "application/cdmi-object",

    			"objectID" : "00007ED9001005192891EEBE599D94BB",

    			"objectName" : "MyVersionedDataObject.txt",

    			"parentURI" : "/MyContainer/",

    			"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    			"domainURI" : "/cdmi_domains/MyDomain/", 

    			"capabilitiesURI" : "/cdmi_capabilities/dataobject/dataobject_version/", 

    			"completionStatus" : "Complete", 

    			"mimetype" : "text/plain", 

    			"metadata" : {

    				"cdmi_size" : "34",

    				"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    				"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    				"cdmi_version_oldest" : [

    					"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    				],

    				"cdmi_version_parent" : "/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA",

    				"cdmi_version_children" : [

    					"/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC"

    				],

    				... 

    			},

    			"valuerange" : "0-33", 

    			"valuetransferencoding" : "utf-8", 

    			"value" : "Second version of this Data Object"

    		},

    		{

    			"objectType" : "application/cdmi-object",

    			"objectID" : "00007ED90010512EB55A9304EAC5D4AA",

    			"objectName" : "MyVersionedDataObject.txt",

    			"parentURI" : "/MyContainer/",

    			"parentID" : "00007E7F00102E230ED82694DAA975D2", 

    			"domainURI" : "/cdmi_domains/MyDomain/", 

    			"capabilitiesURI" : "/cdmi_capabilities/dataobject/dataobject_version/", 

    			"completionStatus" : "Complete", 

    			"mimetype" : "text/plain", 

    			"metadata" : {

    				"cdmi_size" : "33",

    				"cdmi_version_object" : "/cdmi_objectid/00007ED900100DA32EC94351F8970400",

    				"cdmi_version_current" : "/cdmi_objectid/00007ED90010F077F4EB1C99C87524CC",

    				"cdmi_version_oldest" : [

    					"/cdmi_objectid/00007ED90010512EB55A9304EAC5D4AA"

    				],

    				"cdmi_version_children" : [

    					"/cdmi_objectid/00007ED9001005192891EEBE599D94BB"

    				],

    				... 

    			},

    			"valuerange" : "0-32", 

    			"valuetransferencoding" : "utf-8", 

    			"value" : "First version of this Data Object"

    		}

    	]

    }

Serializing a non-version-enabled data object that has versions shall serialize the data object, the versioning-related metadata, and all historical versions. The contents of the value field of the data object, the current version, and all historical versions serialized as data objects shall be contained within a JSON array. These data objects shall replace the contents of the value field of the serialized representation of the version-enabled data object.

Deserializing either a version-enabled data object or a non-version-enabled data object with versions shall restore the data object and all serialized versions.

Serializing and deserializing a data object version shall not be permitted.

Attempting to deserialize a serialized version-enabled data object or non-version-enabled data object with versions onto a system that does not support versions shall result in an HTTP status code of ``400 Bad Request``. This error code results because a CDMI system that does not support versions expects a JSON string for the value field of a serialized data object, not a JSON array.
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
Bibliography<A NAME="50532485_34420"></A>
************************
<DIV>

.. _50532485_62675:
CRC
     Williams, Ross, "A Painless Guide to CRC Error Detection Algorithms", Chapter 16, August 1993, <A HREF="http://www.repairfaq.org/filipg/LINK/F_crc_v3.html" CLASS="URL">http://www.repairfaq.org/filipg/LINK/F_crc_v3.html</A>

</DIV>
<DIV>

.. _50532485_56408:
OCCI

<A HREF="http://occi-wg.org/about/specification/" CLASS="URL">"Open Cloud Computing Interface", Version 1.1, June 2011. Specification - http://occi-wg.org/about/specification/</A>
</DIV>
<DIV>

.. _50532485_91904:
PKS12
     <A HREF="http://www.rsa.com/rsalabs/node.asp?id=2138" CLASS="URL">RSA Laboratories, PKCS #12: Personal Information Exchange Syntax, Version 1.0, June 1999. Specification and Technical Corrigendum - </A>http://www.rsa.com/rsalabs/node.asp?id=2138

</DIV>
<DIV>

.. _50532485_79706:
REST
     "Representational State Transfer" - <A HREF="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" CLASS="URL">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</A>

</DIV>
<DIV>

.. _50532485_39610:
RESTful Web
     Richardson, Leonard and Sam Ruby, RESTful Web Services, O'Reilly, 2007.
</DIV>
<DIV>

.. _50532485_68532:
INCITS 464-2010
<P CLASS="SCSIParagraph">
Information Technology - Information Management - Extensible Access Method (XAM™)</P>
</DIV>
</DIV>
</BODY>
</HTML>
